<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>kube-proxy 工作模式分析</title>
      <link href="/legend-blog/2022/04/19/kube-proxy-%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90/"/>
      <url>/legend-blog/2022/04/19/kube-proxy-%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/legend-blog/assets/css/APlayer.min.css"><script src="/legend-blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、-Services"><a href="#一、-Services" class="headerlink" title="一、 Services"></a>一、 Services</h2><h3 id="1、集群所有-services-信息如下："><a href="#1、集群所有-services-信息如下：" class="headerlink" title="1、集群所有 services 信息如下："></a>1、集群所有 services 信息如下：</h3><pre class="line-numbers language-none"><code class="language-none">root@kube:~# kubectl get svc --all-namespacesNAMESPACE     NAME                   TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                        AGEdefault       appsvc1                ClusterIP   10.99.235.135    &lt;none&gt;        80/TCP                         42ddefault       appsvc2                ClusterIP   10.102.67.19     &lt;none&gt;        80/TCP                         42ddefault       coredns                ClusterIP   10.108.180.158   &lt;none&gt;        53/UDP,53/TCP                  19ddefault       coredns-headless       ClusterIP   None             &lt;none&gt;        53/UDP,53/TCP                  19ddefault       kubernetes             ClusterIP   10.96.0.1        &lt;none&gt;        443/TCP                        62dingress       default-backend        ClusterIP   10.100.169.254   &lt;none&gt;        80/TCP                         42dingress       nginx-ingress          NodePort    10.97.11.0       &lt;none&gt;        80:30000/TCP,18080:32000/TCP   42dingress       nginx-ingress-latest   NodePort    10.105.76.172    &lt;none&gt;        80:30001/TCP,18080:32001/TCP   10dkube-system   calico-etcd            ClusterIP   10.96.232.136    &lt;none&gt;        6666/TCP                       47hkube-system   kube-dns               ClusterIP   10.96.0.10       &lt;none&gt;        53/UDP,53/TCP                  62dkube-system   tiller-deploy          ClusterIP   10.99.131.10     &lt;none&gt;        44134/TCP                      50d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、重点关注-ClusterIP-service："><a href="#2、重点关注-ClusterIP-service：" class="headerlink" title="2、重点关注  ClusterIP service："></a>2、重点关注  ClusterIP service：</h3><pre class="line-numbers language-none"><code class="language-none">root@kube:~# kubectl describe svc -n=default appsvc2Name:              appsvc2Namespace:         defaultLabels:            &lt;none&gt;Annotations:       &lt;none&gt;Selector:          app=app2Type:              ClusterIPIP:                10.102.67.19Port:              &lt;unset&gt;  80/TCPTargetPort:        80/TCPEndpoints:         192.168.42.138:80,192.168.42.189:80Session Affinity:  NoneEvents:            &lt;none&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、和-ingress-nginx-ingress-latest-NodePort-service-和-NodePort-service"><a href="#3、和-ingress-nginx-ingress-latest-NodePort-service-和-NodePort-service" class="headerlink" title="3、和 ingress/nginx-ingress-latest NodePort service:和  NodePort service"></a>3、和 <code>ingress/nginx-ingress-latest </code>NodePort service:和  NodePort service</h3><pre class="line-numbers language-none"><code class="language-none">root@kube:~# kubectl describe svc -n=ingress nginx-ingress-latestName:                     nginx-ingress-latestNamespace:                ingressLabels:                   &lt;none&gt;Annotations:              &lt;none&gt;Selector:                 app=nginx-ingress-lb-latestType:                     NodePortIP:                       10.105.76.172Port:                     http  80/TCPTargetPort:               80/TCPNodePort:                 http  30001/TCPEndpoints:                10.0.2.15:80Port:                     http-mgmt  18080/TCPTargetPort:               18080/TCPNodePort:                 http-mgmt  32001/TCPEndpoints:                10.0.2.15:18080Session Affinity:         NoneExternal Traffic Policy:  ClusterEvents:                   &lt;none&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、iptables-介绍"><a href="#二、iptables-介绍" class="headerlink" title="二、iptables 介绍"></a>二、iptables 介绍</h2><p>Iptables 由 filter, nat, mangle, raw, security 等几个 table 组成。一个 table 由内置的 chains 和 一些用户自定的 chains 组成。</p><p>每个 chain 由一系列的用于匹配封包（packet）的 rules 组成，rule 指定了如果一个 packet 匹配将要执行的操作，也称为 target。</p><p>rules 是顺序匹配的，如果一条 rule 没有匹配，则尝试匹配下一条 rule。如果一条 rule 匹配了，那么下一条 rule 由这一条 rule 的 target 值指定。target 可以为内置的 ACCEPT, DROP, LOG 等，也可以是一条用户自定义 chain，或者是 iptables-extensions(8) 里定义的扩展。</p><p>Iptables 根据流量包是否从外部进入，是否需要转发以及是否从本机生成为封包指定不同的流经路径，具体描述如下图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7Ys1TronmcSRwYSGBaYjY0miaxUIQ6iakNBibC459Dn53AlUdKia4zaTrIdBC4677w97BJZwwDfmzAWLZA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h2 id="三、iptables-模式"><a href="#三、iptables-模式" class="headerlink" title="三、iptables 模式"></a>三、iptables 模式</h2><h4 id="1、入流量"><a href="#1、入流量" class="headerlink" title="1、入流量"></a>1、入流量</h4><p>入流量是指由集群外部访问 service 的流量。</p><p>Iptables 入流量的 chain 路径是 PREROUTING@nat -&gt; INPUT@nat。</p><h4 id="2、ClusterIP"><a href="#2、ClusterIP" class="headerlink" title="2、ClusterIP"></a>2、ClusterIP</h4><p>所有入流量跳转到 <code>KUBE-SERVICES </code>target chain:</p><pre class="line-numbers language-none"><code class="language-none">Chain PREROUTING (policy ACCEPT 0 packets, 0 bytes)Chain PREROUTING (policy ACCEPT 0 packets, 0 bytes)pkts bytes target     prot opt in     out     source               destination    9   558 KUBE-SERVICES  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* kubernetes service portals */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>KUBE-SERVICES chain 里为每个 ClusterIP service 定义一个名为 KUBE-SERVICE-XXX 格式的<br>target chain，匹配条件是 destination 为 service cluster ip 加上 dpt 为 service<br>port；又为所有 NodePort services 定义了一个 KUBE-NODEPORTS 的 target<br>chain（最后一项），其匹配条件是 ADDRTYPE match dst-type LOCAL，即目标地址为集群 Node 拥有的地址，符合<br>NodePort 的定义:</p><pre class="line-numbers language-none"><code class="language-none">Chain KUBE-SERVICES (2 references)pkts bytes target     prot opt in     out     source               destination    0     0 KUBE-SVC-TCOU7JCQXEZGVUNU  udp  --  *      *       0.0.0.0/0            10.96.0.10           /* kube-system/kube-dns:dns cluster IP */ udp dpt:53    0     0 KUBE-SVC-4GOEBHW6OL3YSQ2  tcp  --  *      *       0.0.0.0/0            10.102.67.19         /* default/appsvc2: cluster IP */ tcp dpt:80    0     0 KUBE-SVC-H5SZ7UDBLB6PDUBU  tcp  --  *      *       0.0.0.0/0            10.97.11.0           /* ingress/nginx-ingress:http cluster IP */ tcp dpt:80    0     0 KUBE-SVC-RZBECLZWZRO5HL2J  tcp  --  *      *       0.0.0.0/0            10.105.76.172        /* ingress/nginx-ingress-latest:http cluster IP */ tcp dpt:80    0     0 KUBE-SVC-3DNKG2EQFQUJBSES  tcp  --  *      *       0.0.0.0/0            10.105.76.172        /* ingress/nginx-ingress-latest:http-mgmt cluster IP */ tcp dpt:18080    0     0 KUBE-SVC-K7J76NXP7AUZVFGS  tcp  --  *      *       0.0.0.0/0            10.99.131.10         /* kube-system/tiller-deploy:tiller cluster IP */ tcp dpt:44134    0     0 KUBE-SVC-PFRDUXZEVBX5AIDC  tcp  --  *      *       0.0.0.0/0            10.108.180.158       /* default/coredns:dns-tcp cluster IP */ tcp dpt:53    0     0 KUBE-SVC-BA5PBP57CSS4A4H3  tcp  --  *      *       0.0.0.0/0            10.97.11.0           /* ingress/nginx-ingress:http-mgmt cluster IP */ tcp dpt:18080    0     0 KUBE-SVC-JKXIOCCBPZXMHNK3  udp  --  *      *       0.0.0.0/0            10.108.180.158       /* default/coredns:dns cluster IP */ udp dpt:53    0     0 KUBE-SVC-BVEYTIW5E7VAUTUJ  tcp  --  *      *       0.0.0.0/0            10.100.169.254       /* ingress/default-backend: cluster IP */ tcp dpt:80    0     0 KUBE-SVC-ERIFXISQEP7F7OF4  tcp  --  *      *       0.0.0.0/0            10.96.0.10           /* kube-system/kube-dns:dns-tcp cluster IP */ tcp dpt:53    0     0 KUBE-SVC-JNI67WSAMQHGRFK3  tcp  --  *      *       0.0.0.0/0            10.99.235.135        /* default/appsvc1: cluster IP */ tcp dpt:80    0     0 KUBE-SVC-NPX46M4PTMTKRN6Y  tcp  --  *      *       0.0.0.0/0            10.96.0.1            /* default/kubernetes:https cluster IP */ tcp dpt:443    0     0 KUBE-SVC-NTYB37XIWATNM25Y  tcp  --  *      *       0.0.0.0/0            10.96.232.136        /* kube-system/calico-etcd: cluster IP */ tcp dpt:6666  19  1140 KUBE-NODEPORTS  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* kubernetes service nodeports; NOTE: this must be the last rule in this chain */ ADDRTYPE match dst-type LOCAL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先来观察 ClusterIP service 的 target chain，以 KUBE-SVC-4GOEBHW6OL3YSQ2S(default/appsvc2) 举例：</p><p>这个 service chain 里为每个后端 endpoint 设置了一条 target chain，名为 KUBE-SEP-XXX 形式，并定义了每条 0.5 的访问比例，也就是 service 负载均衡的 ROUND ROBIN 策略。</p><p>其中一个 endpoint 对应的 chain 规则如下：</p><pre class="line-numbers language-none"><code class="language-none">Chain KUBE-SEP-T53XQEOLG435KKJB (1 references)pkts bytes target     prot opt in     out     source               destination    0     0 KUBE-MARK-MASQ  all  --  *      *       192.168.42.138       0.0.0.0/0    0     0 DNAT       tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp to:192.168.42.138:80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里虽然定义了两条规则，但此时流量只会匹配到 DNAT 这一条规则，匹配条件是 destination:<br>192.168.42.138:80，即目标地址为后端 endpoint 地址，其 target 是将 ClusterIP 的流量使用<br>DNAT（Destination NAT）的方式转发到后端 endpoint(192.168.42.138:80)。</p><h4 id="3、NodePort"><a href="#3、NodePort" class="headerlink" title="3、NodePort"></a>3、NodePort</h4><p>上面提到，所有 NodePort 入流量会匹配到 KUBE-NODEPORTS chain。这个 chain 里为每个 NodePort service 定义了两条规则，先关注 target 为 KUBE-SVC-XXX chain 形式的规则，以 KUBE-SVC-RZBECLZWZRO5HL2J 举例，其匹配条件是 tcp dpt:30001，即该 service(ingress/nginx-ingress-latest) 的 NodePort：(注：这里也会同时匹配 KUBE-MARK-MASQ 规则，但是这对封包的流经路径没有影响，见下面的出流量分析。)</p><pre class="line-numbers language-none"><code class="language-none">Chain KUBE-NODEPORTS (1 references)pkts bytes target     prot opt in     out     source               destination    0     0 KUBE-MARK-MASQ  tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            /* ingress/nginx-ingress:http */ tcp dpt:30000    0     0 KUBE-SVC-H5SZ7UDBLB6PDUBU  tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            /* ingress/nginx-ingress:http */ tcp dpt:30000    0     0 KUBE-MARK-MASQ  tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            /* ingress/nginx-ingress-latest:http */ tcp dpt:30001    0     0 KUBE-SVC-RZBECLZWZRO5HL2J  tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            /* ingress/nginx-ingress-latest:http */ tcp dpt:30001    0     0 KUBE-MARK-MASQ  tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            /* ingress/nginx-ingress-latest:http-mgmt */ tcp dpt:32001    0     0 KUBE-SVC-3DNKG2EQFQUJBSES  tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            /* ingress/nginx-ingress-latest:http-mgmt */ tcp dpt:32001    0     0 KUBE-MARK-MASQ  tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            /* ingress/nginx-ingress:http-mgmt */ tcp dpt:32000    0     0 KUBE-SVC-BA5PBP57CSS4A4H3  tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            /* ingress/nginx-ingress:http-mgmt */ tcp dpt:32000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>KUBE-SVC-RZBECLZWZRO5HL2J chain 又跳转到 KUBE-SEP-B25KHNOUZSX4F53T target:</p><pre class="line-numbers language-none"><code class="language-none">Chain KUBE-SVC-RZBECLZWZRO5HL2J (2 references)pkts bytes target     prot opt in     out     source               destination    0     0 KUBE-SEP-B25KHNOUZSX4F53T  all  --  *      *       0.0.0.0/0            0.0.0.0/0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>KUBE-SEP-B25KHNOUZSX4F53T chain 内容如下，其功能是使用 DNAT 将流量转发到后端 enpoint，与 ClusterIP service 无异:</p><pre class="line-numbers language-none"><code class="language-none">Chain KUBE-SEP-B25KHNOUZSX4F53T (1 references)pkts bytes target     prot opt in     out     source               destination    0     0 KUBE-MARK-MASQ  all  --  *      *       10.0.2.15            0.0.0.0/0    0     0 DNAT       tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp to:10.0.2.15:80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4、出流量"><a href="#4、出流量" class="headerlink" title="4、出流量"></a>4、出流量</h3><p>出流量是指由集群内的 pod 访问 service 的流量。</p><p>Iptables 出流量的 chain 路径是 OUTPUT@nat -&gt; POSTROUTING@nat。</p><p>OUTPUT chain 如下，与入流量情形一样，也是所有流量跳转到 KUBE-SERVICES chain：</p><pre class="line-numbers language-none"><code class="language-none">Chain OUTPUT (policy ACCEPT 24 packets, 1440 bytes)pkts bytes target     prot opt in     out     source               destination  804 48270 cali-OUTPUT  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* cali:tVnHkvAo15HuiPy0 */  870 52230 KUBE-SERVICES  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* kubernetes service portals */  384 23040 DOCKER     all  --  *      *       0.0.0.0/0           !127.0.0.0/8          ADDRTYPE match dst-type LOCALClusterIP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与入流量类似，ClusterIP service 的出流量也会匹配到各自 service 的 target chain:</p><pre class="line-numbers language-none"><code class="language-none">Chain KUBE-SERVICES (2 references)pkts bytes target     prot opt in     out     source               destination    0     0 KUBE-SVC-TCOU7JCQXEZGVUNU  udp  --  *      *       0.0.0.0/0            10.96.0.10           /* kube-system/kube-dns:dns cluster IP */ udp dpt:53    0     0 KUBE-SVC-4GOEBHW6OL3YSQ2  tcp  --  *      *       0.0.0.0/0            10.102.67.19         /* default/appsvc2: cluster IP */ tcp dpt:80    0     0 KUBE-SVC-H5SZ7UDBLB6PDUBU  tcp  --  *      *       0.0.0.0/0            10.97.11.0           /* ingress/nginx-ingress:http cluster IP */ tcp dpt:80    0     0 KUBE-SVC-RZBECLZWZRO5HL2J  tcp  --  *      *       0.0.0.0/0            10.105.76.172        /* ingress/nginx-ingress-latest:http cluster IP */ tcp dpt:80    0     0 KUBE-SVC-3DNKG2EQFQUJBSES  tcp  --  *      *       0.0.0.0/0            10.105.76.172        /* ingress/nginx-ingress-latest:http-mgmt cluster IP */ tcp dpt:18080    0     0 KUBE-SVC-K7J76NXP7AUZVFGS  tcp  --  *      *       0.0.0.0/0            10.99.131.10         /* kube-system/tiller-deploy:tiller cluster IP */ tcp dpt:44134    0     0 KUBE-SVC-PFRDUXZEVBX5AIDC  tcp  --  *      *       0.0.0.0/0            10.108.180.158       /* default/coredns:dns-tcp cluster IP */ tcp dpt:53    0     0 KUBE-SVC-BA5PBP57CSS4A4H3  tcp  --  *      *       0.0.0.0/0            10.97.11.0           /* ingress/nginx-ingress:http-mgmt cluster IP */ tcp dpt:18080    0     0 KUBE-SVC-JKXIOCCBPZXMHNK3  udp  --  *      *       0.0.0.0/0            10.108.180.158       /* default/coredns:dns cluster IP */ udp dpt:53    0     0 KUBE-SVC-BVEYTIW5E7VAUTUJ  tcp  --  *      *       0.0.0.0/0            10.100.169.254       /* ingress/default-backend: cluster IP */ tcp dpt:80    0     0 KUBE-SVC-ERIFXISQEP7F7OF4  tcp  --  *      *       0.0.0.0/0            10.96.0.10           /* kube-system/kube-dns:dns-tcp cluster IP */ tcp dpt:53    0     0 KUBE-SVC-JNI67WSAMQHGRFK3  tcp  --  *      *       0.0.0.0/0            10.99.235.135        /* default/appsvc1: cluster IP */ tcp dpt:80    0     0 KUBE-SVC-NPX46M4PTMTKRN6Y  tcp  --  *      *       0.0.0.0/0            10.96.0.1            /* default/kubernetes:https cluster IP */ tcp dpt:443    0     0 KUBE-SVC-NTYB37XIWATNM25Y  tcp  --  *      *       0.0.0.0/0            10.96.232.136        /* kube-system/calico-etcd: cluster IP */ tcp dpt:6666  19  1140 KUBE-NODEPORTS  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* kubernetes service nodeports; NOTE: this must be the last rule in this chain */ ADDRTYPE match dst-type LOCAL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>跳转以后，还是以 KUBE-SVC-4GOEBHW6OL3YSQ2S(default/appsvc2) 举例，又跳转到 endpoint 对应的 target chain：</p><pre class="line-numbers language-none"><code class="language-none">Chain KUBE-SVC-4GOEBHW6OL3YSQ2S (1 references)pkts bytes target     prot opt in     out     source               destination    0     0 KUBE-SEP-T53XQEOLG435KKJB  all  --  *      *       0.0.0.0/0            0.0.0.0/0            statistic mode random probability 0.50000000000    0     0 KUBE-SEP-KDPNMEHXV7C5OGG2  all  --  *      *       0.0.0.0/0            0.0.0.0/0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 endpoint 对应的 chain 里，出流量会匹配第一条规则，匹配条件是 source: 192.168.42.138，即来源地址是后端 endpoint:</p><pre class="line-numbers language-none"><code class="language-none">Chain KUBE-SEP-T53XQEOLG435KKJB (1 references)pkts bytes target     prot opt in     out     source               destination    0     0 KUBE-MARK-MASQ  all  --  *      *       192.168.42.138       0.0.0.0/0    0     0 DNAT       tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp to:192.168.42.138:80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时封包进一步跳转进入到 KUBE-MARK-MASQ chain 中，其规则就一条，给流量封包打上 0x4000 的标记：</p><pre class="line-numbers language-none"><code class="language-none">Chain KUBE-MARK-MASQ (25 references)pkts bytes target     prot opt in     out     source               destination    0     0 MARK       all  --  *      *       0.0.0.0/0            0.0.0.0/0            MARK or 0x4000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至此出流量的 OUTPUT chain 走完。接下来进行 POSTROUTING chain：</p><pre class="line-numbers language-none"><code class="language-none">Chain POSTROUTING (policy ACCEPT 24 packets, 1440 bytes)pkts bytes target     prot opt in     out     source               destination  804 48270 cali-POSTROUTING  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* cali:O3lYWMrLQYEMJtB5 */  870 52230 KUBE-POSTROUTING  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* kubernetes postrouting rules */    0     0 MASQUERADE  all  --  *      !docker0  172.18.0.0/16        0.0.0.0/0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里出流量跳转到 KUBE-POSTROUTING chain：(疑问：cali-POSTROUTING 和 KUBE-POSTROUTING 匹配规则一致，第一条为什么没有屏蔽第二条的执行呢？有待进一步调查。)</p><pre class="line-numbers language-none"><code class="language-none">Chain KUBE-POSTROUTING (1 references)pkts bytes target     prot opt in     out     source               destination    0     0 MASQUERADE  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* kubernetes service traffic requiring SNAT */ mark match 0x4000/0x4000 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>KUBE-POSTROUTING chain 很简单，就是将之前标记过 0x4000 的封包进行 MASQUERADE。MASQUERADE<br>是一种更健壮的 SNAT，即将封包的源地址由后端的 endpoint 变更为 Cluster IP。之所以在这里进行源地址转换，是因为由<br>endpoint(pod1) 的发出的请求封包， 经过 service 的分发到达另一个 endpoint(pod2) 时，由于所有的<br>endpoints(pods) 都处于同一子网，根据路由定义在一个子网的流量封包不会经过路由，而是直接返回到请求 pod。请求封包此前不做<br>SNAT 的话，因为请求 endpoint(pod1) 访问的地址是 Cluster IP，返回封包的源地址却是 pod2<br>的地址，因此这个响应包会被拒绝。解决办法就是 pod1 访问 service（会被分发到 pod2）时，使用 SNAT(MASQUERADE)<br>伪装源地址为 ClusterIP，这样 pod2 的返回封包就会经过 service 的进一步路由。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7Ys1TronmcSRwYSGBaYjY0miaEDoMZBXRt4DzbjUC3h77Lhjp4mnstTjkLftcOich8R0I0Df5vR4fJCQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="5、NodePort"><a href="#5、NodePort" class="headerlink" title="5、NodePort"></a>5、NodePort</h4><p>与 ClusterIP service 不同，在 KUBE-SERVICES chain 中，NodePort service 的出流量只会匹配最后一项的 KUBE-NODEPORTS target:</p><pre class="line-numbers language-none"><code class="language-none">Chain KUBE-SERVICES (2 references)pkts bytes target     prot opt in     out     source               destination    0     0 KUBE-SVC-TCOU7JCQXEZGVUNU  udp  --  *      *       0.0.0.0/0            10.96.0.10           /* kube-system/kube-dns:dns cluster IP */ udp dpt:53    0     0 KUBE-SVC-4GOEBHW6OL3YSQ2  tcp  --  *      *       0.0.0.0/0            10.102.67.19         /* default/appsvc2: cluster IP */ tcp dpt:80    0     0 KUBE-SVC-H5SZ7UDBLB6PDUBU  tcp  --  *      *       0.0.0.0/0            10.97.11.0           /* ingress/nginx-ingress:http cluster IP */ tcp dpt:80    0     0 KUBE-SVC-RZBECLZWZRO5HL2J  tcp  --  *      *       0.0.0.0/0            10.105.76.172        /* ingress/nginx-ingress-latest:http cluster IP */ tcp dpt:80    0     0 KUBE-SVC-3DNKG2EQFQUJBSES  tcp  --  *      *       0.0.0.0/0            10.105.76.172        /* ingress/nginx-ingress-latest:http-mgmt cluster IP */ tcp dpt:18080    0     0 KUBE-SVC-K7J76NXP7AUZVFGS  tcp  --  *      *       0.0.0.0/0            10.99.131.10         /* kube-system/tiller-deploy:tiller cluster IP */ tcp dpt:44134    0     0 KUBE-SVC-PFRDUXZEVBX5AIDC  tcp  --  *      *       0.0.0.0/0            10.108.180.158       /* default/coredns:dns-tcp cluster IP */ tcp dpt:53    0     0 KUBE-SVC-BA5PBP57CSS4A4H3  tcp  --  *      *       0.0.0.0/0            10.97.11.0           /* ingress/nginx-ingress:http-mgmt cluster IP */ tcp dpt:18080    0     0 KUBE-SVC-JKXIOCCBPZXMHNK3  udp  --  *      *       0.0.0.0/0            10.108.180.158       /* default/coredns:dns cluster IP */ udp dpt:53    0     0 KUBE-SVC-BVEYTIW5E7VAUTUJ  tcp  --  *      *       0.0.0.0/0            10.100.169.254       /* ingress/default-backend: cluster IP */ tcp dpt:80    0     0 KUBE-SVC-ERIFXISQEP7F7OF4  tcp  --  *      *       0.0.0.0/0            10.96.0.10           /* kube-system/kube-dns:dns-tcp cluster IP */ tcp dpt:53    0     0 KUBE-SVC-JNI67WSAMQHGRFK3  tcp  --  *      *       0.0.0.0/0            10.99.235.135        /* default/appsvc1: cluster IP */ tcp dpt:80    0     0 KUBE-SVC-NPX46M4PTMTKRN6Y  tcp  --  *      *       0.0.0.0/0            10.96.0.1            /* default/kubernetes:https cluster IP */ tcp dpt:443    0     0 KUBE-SVC-NTYB37XIWATNM25Y  tcp  --  *      *       0.0.0.0/0            10.96.232.136        /* kube-system/calico-etcd: cluster IP */ tcp dpt:6666  19  1140 KUBE-NODEPORTS  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* kubernetes service nodeports; NOTE: this must be the last rule in this chain */ ADDRTYPE match dst-type LOCAL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 KUBE-NODEPORTS 中，与入流量的 NodePort 服务相同，出流量也会匹配到某个 KUBE-SERVICE-XXX，以<br>KUBE-SVC-RZBECLZWZRO5HL2J(ingress/nginx-ingress-latest) 举例，其匹配条件是 tcp<br>dpt:30001，即出流量目标端口是该 service 的 NodePort。(注：这里也会同时匹配 KUBE-MARK-MASQ<br>规则，直接对封包打标记，原因未知。)</p><pre class="line-numbers language-none"><code class="language-none">Chain KUBE-NODEPORTS (1 references)pkts bytes target     prot opt in     out     source               destination    0     0 KUBE-MARK-MASQ  tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            /* ingress/nginx-ingress:http */ tcp dpt:30000    0     0 KUBE-SVC-H5SZ7UDBLB6PDUBU  tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            /* ingress/nginx-ingress:http */ tcp dpt:30000    0     0 KUBE-MARK-MASQ  tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            /* ingress/nginx-ingress-latest:http */ tcp dpt:30001    0     0 KUBE-SVC-RZBECLZWZRO5HL2J  tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            /* ingress/nginx-ingress-latest:http */ tcp dpt:30001    0     0 KUBE-MARK-MASQ  tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            /* ingress/nginx-ingress-latest:http-mgmt */ tcp dpt:32001    0     0 KUBE-SVC-3DNKG2EQFQUJBSES  tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            /* ingress/nginx-ingress-latest:http-mgmt */ tcp dpt:32001    0     0 KUBE-MARK-MASQ  tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            /* ingress/nginx-ingress:http-mgmt */ tcp dpt:32000    0     0 KUBE-SVC-BA5PBP57CSS4A4H3  tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            /* ingress/nginx-ingress:http-mgmt */ tcp dpt:32000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>KUBE-SVC-RZBECLZWZRO5HL2J chain 又跳转到 KUBE-SEP-B25KHNOUZSX4F53T target:</p><pre class="line-numbers language-none"><code class="language-none">Chain KUBE-SVC-RZBECLZWZRO5HL2J (2 references)pkts bytes target     prot opt in     out     source               destination    0     0 KUBE-SEP-B25KHNOUZSX4F53T  all  --  *      *       0.0.0.0/0            0.0.0.0/0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面入流量的分析中有提到，入流量会匹配这里的 DNAT 规则，而出流量只会匹配到 KUBE-MARK-MASQ 这条规则，其匹配条件是来源地址为 source: 10.0.2.15，即来源地址为 endpoint 地址。</p><pre class="line-numbers language-none"><code class="language-none">Chain KUBE-SEP-B25KHNOUZSX4F53T (1 references)pkts bytes target     prot opt in     out     source               destination    0     0 KUBE-MARK-MASQ  all  --  *      *       10.0.2.15            0.0.0.0/0    0     0 DNAT       tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp to:10.0.2.15:80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>跳转后进入的 KUBE-MARK-MASQ chain 其规则就一条，给流量封包打上 0x4000 的标记：</p><pre class="line-numbers language-none"><code class="language-none">Chain KUBE-MARK-MASQ (25 references)pkts bytes target     prot opt in     out     source               destination    0     0 MARK       all  --  *      *       0.0.0.0/0            0.0.0.0/0            MARK or 0x4000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至此出流量的 OUTPUT chain 走完。接下来进行 POSTROUTING chain：</p><pre class="line-numbers language-none"><code class="language-none">Chain POSTROUTING (policy ACCEPT 24 packets, 1440 bytes)pkts bytes target     prot opt in     out     source               destination  804 48270 cali-POSTROUTING  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* cali:O3lYWMrLQYEMJtB5 */  870 52230 KUBE-POSTROUTING  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* kubernetes postrouting rules */    0     0 MASQUERADE  all  --  *      !docker0  172.18.0.0/16        0.0.0.0/0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很简单，出流量跳转到 KUBE-POSTROUTING chain：</p><pre class="line-numbers language-none"><code class="language-none">Chain KUBE-POSTROUTING (1 references)pkts bytes target     prot opt in     out     source               destination    0     0 MASQUERADE  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* kubernetes service traffic requiring SNAT */ mark match 0x4000/0x4000 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>KUBE-POSTROUTING chain 也很简单，就是将之前标记过 0x4000 的封包进行 MASQUERADE。MASQUERADE<br>类似于 SNAT，即将封包的源地址由后端的 backend 转换为 Node ip，需要 MASQUERADE 原因见上面分析。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7Ys1TronmcSRwYSGBaYjY0miaxAmSyahAWBPxJKuuIkaEHUpaatu4zOr5YxxgBq0z1icC6bdDnfmFfrQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h2 id="四、IPVS-模式"><a href="#四、IPVS-模式" class="headerlink" title="四、IPVS 模式"></a>四、IPVS 模式</h2><h3 id="1、入流量-1"><a href="#1、入流量-1" class="headerlink" title="1、入流量"></a>1、入流量</h3><p>入流量是指由集群外部访问 service 的流量。</p><p>Iptables 入流量的 chain 路径是 PREROUTING@nat -&gt; INPUT@nat。</p><h3 id="2、ClusterIP-1"><a href="#2、ClusterIP-1" class="headerlink" title="2、ClusterIP"></a>2、ClusterIP</h3><p>Iptables 入流量的 chain 路径是 PREROUTING@nat -&gt; INPUT@nat。</p><p>在 PREROUTING 阶段，流量跳转到 KUBE-SERVICES target chain:</p><pre class="line-numbers language-none"><code class="language-none">Chain PREROUTING (policy ACCEPT 0 packets, 0 bytes)pkts bytes target     prot opt in     out     source               destination  11   652 cali-PREROUTING  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* cali:6gwbT8clXdHdC1b1 */  12   881 KUBE-SERVICES  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* kubernetes service portals */    3   140 DOCKER     all  --  *      *       0.0.0.0/0            0.0.0.0/0            ADDRTYPE match dst-type LOCAL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>KUBE-SERVICES chain 如下：</p><pre class="line-numbers language-none"><code class="language-none">Chain KUBE-SERVICES (2 references)pkts bytes target     prot opt in     out     source               destination    0     0 KUBE-MARK-MASQ  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* Kubernetes service cluster ip + port for masquerade purpose */ match-set KUBE-CLUSTER-IP src,dst    8   480 KUBE-NODE-PORT  all  --  *      *       0.0.0.0/0            0.0.0.0/0            ADDRTYPE match dst-type LOCAL    0     0 ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0            match-set KUBE-CLUSTER-IP dst,dst<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ClusterIP service 的访问流量会匹配 KUBE-MARK-MASQ，其匹配规则是 match-set KUBE-CLUSTER-IP src,dst，即封包的 src 或者 dest 地址匹配内核中名为 KUBE-CLUSTER-IP 的 ipset。</p><p>下一步就是为这些包打上标记：</p><pre class="line-numbers language-none"><code class="language-none">Chain KUBE-MARK-MASQ (3 references)pkts bytes target     prot opt in     out     source               destination    0     0 MARK       all  --  *      *       0.0.0.0/0            0.0.0.0/0            MARK or 0x4000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与 iptables 模式不同的是，此时封包在 iptables 的路径已经走完，并没有后续的 DNAT 到后端 endpoint 的流程，这一步的工作交由 IPVS 来完成。</p><p>对于 default/appsvc2 ClusterIP service，其 IPVS 配置如下：</p><pre class="line-numbers language-none"><code class="language-none">root@kube:~# ipvsadm -lnIP Virtual Server version 1.2.1 (size=4096)Prot LocalAddress:Port Scheduler Flags  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConnTCP  10.102.67.19:80 rr  -&gt; 192.168.42.134:80            Masq    1      0          0  -&gt; 192.168.42.145:80            Masq    1      0          0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、NodePort-1"><a href="#3、NodePort-1" class="headerlink" title="3、NodePort"></a>3、NodePort</h3><p>对于访问 NodePort service 来说，其流量第一步依然是经由 PREROUTING chain，而后跳转到 KUBE-SERVICES chain。</p><p>在这里封包会匹配到 KUBE-NODE-PORT target chain，其匹配条件是 ADDRTYPE match dst-type LOCAL，即目标地址类型是 Node 配置的地址，这符合 NodePort 的定义。</p><pre class="line-numbers language-none"><code class="language-none">Chain KUBE-SERVICES (2 references)pkts bytes target     prot opt in     out     source               destination    0     0 KUBE-MARK-MASQ  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* Kubernetes service cluster ip + port for masquerade purpose */ match-set KUBE-CLUSTER-IP src,dst    8   480 KUBE-NODE-PORT  all  --  *      *       0.0.0.0/0            0.0.0.0/0            ADDRTYPE match dst-type LOCAL    0     0 ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0            match-set KUBE-CLUSTER-IP dst,dst<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>KUBE-NODE-PORT chain 配置如下，其会匹配符合 KUBE-NODE-PORT-TCP/UDP 的 ipset 的封包：</p><pre class="line-numbers language-none"><code class="language-none">Chain KUBE-NODE-PORT (1 references)pkts bytes target     prot opt in     out     source               destination    0     0 KUBE-MARK-MASQ  tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            /* Kubernetes nodeport TCP port for masquerade purpose */ match-set KUBE-NODE-PORT-TCP dst<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>跳转后进入 KUBE-MARK-MASQ chain，定义如下：</p><pre class="line-numbers language-none"><code class="language-none">Chain KUBE-MARK-MASQ (3 references)pkts bytes target     prot opt in     out     source               destination    0     0 MARK       all  --  *      *       0.0.0.0/0            0.0.0.0/0            MARK or 0x4000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至此封包在 iptables 的路径走完，后面交由 IPVS 来完成 ClusterIP 到 endpoint 的映射。</p><p>对于 ingress/ingress-nginx-latest NodePort service，其 IPVS 配置如下：</p><pre class="line-numbers language-none"><code class="language-none">root@kube:~# ipvsadm -lnIP Virtual Server version 1.2.1 (size=4096)Prot LocalAddress:Port Scheduler Flags  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConnTCP  172.17.8.111:30001 rr  -&gt; 10.0.2.15:80                 Masq    1      0          0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4、出流量-1"><a href="#4、出流量-1" class="headerlink" title="4、出流量"></a>4、出流量</h3><p>出流量是指由集群内的 pod 访问 service 的流量。</p><p>Iptables 出流量的 chain 路径是 OUTPUT@nat -&gt; POSTROUTING@nat。</p><p>OUTPUT chain 如下，与入流量情形一样，也是所有流量跳转到 KUBE-SERVICES chain：</p><pre class="line-numbers language-none"><code class="language-none">Chain OUTPUT (policy ACCEPT 15 packets, 900 bytes)pkts bytes target     prot opt in     out     source               destination  607 36468 cali-OUTPUT  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* cali:tVnHkvAo15HuiPy0 */  687 41156 KUBE-SERVICES  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* kubernetes service portals */  274 16328 DOCKER     all  --  *      *       0.0.0.0/0           !127.0.0.0/8          ADDRTYPE match dst-type LOCAL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而后的动作与入流量一致，不论 ClusterIP service 还是 NodePort service，都是为封包打上 0x4000<br>的标记。区别是至此入流量的 iptables 流程走完，而出流量还需要经过 nat 表的 POSTROUTING chain，其定义如下：</p><pre class="line-numbers language-none"><code class="language-none">Chain POSTROUTING (policy ACCEPT 14 packets, 840 bytes)pkts bytes target     prot opt in     out     source               destination  610 36640 cali-POSTROUTING  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* cali:O3lYWMrLQYEMJtB5 */  690 41328 KUBE-POSTROUTING  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* kubernetes postrouting rules */    0     0 MASQUERADE  all  --  *      !docker0  172.18.0.0/16        0.0.0.0/0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进一步跳转到 KUBE-POSTROUTING chain：Chain KUBE-POSTROUTING (1 references)</p><pre class="line-numbers language-none"><code class="language-none">Chain KUBE-POSTROUTING (1 references)pkts bytes target     prot opt in     out     source               destination    0     0 MASQUERADE  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* kubernetes service traffic requiring SNAT */ mark match 0x4000/0x4000    1    60 MASQUERADE  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* Kubernetes endpoints dst ip:port, source ip for solving hairpin purpose */ match-set KUBE-LOOP-BACK dst,dst,src<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里，会为之前打上 0x4000 标记的出流量封包执行 MASQUERADE target，即类似于 SNAT 的一种操作，将其来源 IP 变更为 ClusterIP 或 Node ip。</p><p>`<img src="https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7Ys1TronmcSRwYSGBaYjY0miaibEWzw2ZmN3J1CZYJTosRWg7qmm5beUC0d1fw6kaYFUk3WQ6jm74APw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h2 id="五、结论"><a href="#五、结论" class="headerlink" title="五、结论"></a>五、结论</h2><p>kube-proxy IPVS 模式依然会使用 iptables 来做封包 MASQUERADE，但是其使用 ipset match 的方式保持了 iptables 规则数量恒定（几条），随着 service 的数量增多，不会出现 iptables 规则过多以及线性匹配的性能瓶颈。这里使用 iptables 与否不是关键，iptalbes 与 IPVS 理论上都是内核 netfilter 模块的客户端，IPVS 这里只是借用 iptables 方便地设置 netfilter 转发。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> iptables </tag>
            
            <tag> ipvs </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Prometheus查询计算Kubernetes集群中Pod 的CPU、内存使用率、流量监控指标</title>
      <link href="/legend-blog/2022/04/17/2022-04-17-Prometheus%E6%9F%A5%E8%AF%A2%E8%AE%A1%E7%AE%97Kubernetes%E9%9B%86%E7%BE%A4%E4%B8%ADPod%20%E7%9A%84CPU%E3%80%81%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E7%8E%87%E3%80%81%E6%B5%81%E9%87%8F%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87/"/>
      <url>/legend-blog/2022/04/17/2022-04-17-Prometheus%E6%9F%A5%E8%AF%A2%E8%AE%A1%E7%AE%97Kubernetes%E9%9B%86%E7%BE%A4%E4%B8%ADPod%20%E7%9A%84CPU%E3%80%81%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E7%8E%87%E3%80%81%E6%B5%81%E9%87%8F%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/legend-blog/assets/css/APlayer.min.css"><script src="/legend-blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、目的"><a href="#一、目的" class="headerlink" title="一、目的"></a>一、目的</h2><p>Kubernetes的kubelet组件内置了cadvisor，将Node上容器的指标以Prometheus支持的格式展示，可以通过这些指标计算得到更多有用的数据.</p><h2 id="二、Kubelet的Cadvisor指标获取"><a href="#二、Kubelet的Cadvisor指标获取" class="headerlink" title="二、Kubelet的Cadvisor指标获取"></a>二、Kubelet的Cadvisor指标获取</h2><h3 id="1、在Prometheus的配置文件中，配置了相关的Target之后，这些指标就可以从Prometheus中查询到。"><a href="#1、在Prometheus的配置文件中，配置了相关的Target之后，这些指标就可以从Prometheus中查询到。" class="headerlink" title="1、在Prometheus的配置文件中，配置了相关的Target之后，这些指标就可以从Prometheus中查询到。"></a>1、在Prometheus的配置文件中，配置了相关的Target之后，这些指标就可以从Prometheus中查询到。</h3><pre class="line-numbers language-none"><code class="language-none">- job_name: 'kubernetes-cadvisor'      scheme: https      tls_config:        ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt      bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token      kubernetes_sd_configs:      - role: node      relabel_configs:      - target_label: __address__        replacement: kubernetes.default.svc:443      - source_labels: [__meta_kubernetes_node_name]        regex: (.+)        replacement: /api/v1/nodes/${1}/proxy/metrics/cadvisor        target_label: __metrics_path__      - action: labelmap        regex: __meta_kubernetes_node_label_(.+)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/realzhangqingwei/realzhangqingwei.github.io/master/imgs_for_blogs/20220417151103.png" alt="20220417151103"></p><h3 id="2、直接访问Kubelet的apiserver接口，可以读取以Prometheus支持的格式呈现的指标："><a href="#2、直接访问Kubelet的apiserver接口，可以读取以Prometheus支持的格式呈现的指标：" class="headerlink" title="2、直接访问Kubelet的apiserver接口，可以读取以Prometheus支持的格式呈现的指标："></a>2、直接访问Kubelet的apiserver接口，可以读取以Prometheus支持的格式呈现的指标：</h3><pre class="line-numbers language-none"><code class="language-none">$ curl https://xx.xx.xx.xx:6443/api/v1/nodes/k8s-master01/proxy/metrics/cadvisor# HELP cadvisor_version_info A metric with a constant '1' value labeled by kernel version, OS version, docker version, cadvisor version &amp; cadvisor revision.# TYPE cadvisor_version_info gaugecadvisor_version_info{cadvisorRevision="",cadvisorVersion="",dockerVersion="17.03.0-ce",kernelVersion="4.9.148",osVersion="CentOS Linux 7 (Core)"} 1# HELP container_cpu_load_average_10s Value of container cpu load average over the last 10 seconds.# TYPE container_cpu_load_average_10s gaugecontainer_cpu_load_average_10s{container_name="",id="/",image="",name="",namespace="",pod_name=""} 0container_cpu_load_average_10s{container_name="",id="/kubepods",image="",name="",namespace="",pod_name=""} 0container_cpu_load_average_10s{container_name="",id="/kubepods/besteffort",image="",name="",namespace="",pod_name=""} 0container_cpu_load_average_10s{container_name="",id="/kubepods/besteffort/pod79bfae8f-0f25-11e9-bbb3-28b4484d8d14",image="",name="",namespace="",pod_name=""} 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、Pod-CPU使用率的计算"><a href="#3、Pod-CPU使用率的计算" class="headerlink" title="3、Pod CPU使用率的计算"></a>3、Pod CPU使用率的计算</h3><p>从man top手册中找到了CPU使用率的定义：</p><pre class="line-numbers language-none"><code class="language-none">1. %CPU -- CPU Usage The task's share of the elapsed CPU time since the last screen update, expressed as a percentage of total CPU time.In a true SMP environment, if a process is multi-threaded and top is not operating in Threads mode, amounts greater than 100% may be reported. You toggle Threads mode with the `H' inter-active command.Also for multi-processor environments, if Irix mode is Off, top will operate in Solaris mode where a task's cpu usage will be divided by the total number of CPUs. You toggle Irix/Solaris modes with the `I' interactive command.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>即在过去的一段时间里进程占用的CPU时间与CPU总时间的比率，如果有多个CPU或者多核，需要将每个CPU的时间相加。<br>kubelet中的cadvisor采集的指标与含义，见：Monitoring cAdvisor with Prometheus。</p><p>其中有几项是：</p><table><thead><tr><th>Metric name</th><th>Type</th><th>Description</th><th>Unit</th></tr></thead><tbody><tr><td>container_cpu_usage_seconds_total</td><td>Counter</td><td>Cumulative cpu time consumed</td><td>seconds</td></tr><tr><td>container_spec_cpu_quota</td><td>Gauge</td><td>CPU quota of the container</td><td></td></tr><tr><td>container_memory_rss</td><td>Gauge</td><td>Size of RSS</td><td>bytes</td></tr><tr><td>container_spec_memory_limit_bytes</td><td>Gauge</td><td>Memory limit for the container</td><td>bytes</td></tr><tr><td>container_fs_usage_bytes</td><td>Gauge</td><td>Number of bytes that are consumed by the container on this filesystem</td><td>bytes</td></tr></tbody></table><p>container_cpu_usage_seconds_total是container累计使用的CPU时间，用它除以CPU的总时间，就得到了容器的CPU使用率。</p><p>Pod 在1s内累计使用的CPU时间为：</p><pre class="line-numbers language-none"><code class="language-none">sum(rate(container_cpu_usage_seconds_total{image!=""}[1m])) by (pod_name, namespace)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>container_spec_cpu_quota</code>是容器的CPU配额，它的值是：为容器指定的CPU个数*100000。</p><p>故，Pod在1s内CPU的总时间为：Pod的CPU核数 * 1s：</p><pre class="line-numbers language-none"><code class="language-none">(sum(container_spec_cpu_quota{image!=""}/100000) by (pod_name, namespace))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将上面两个公式的结果相除，就得到了容器的CPU使用率：</p><pre class="line-numbers language-none"><code class="language-none">sum(rate(container_cpu_usage_seconds_total{image!=""}[1m])) by (pod_name, namespace) / (sum(container_spec_cpu_quota{image!=""}/100000) by (pod_name, namespace)) * 100<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4、Pod内存使用率的计算"><a href="#4、Pod内存使用率的计算" class="headerlink" title="4、Pod内存使用率的计算"></a>4、Pod内存使用率的计算</h3><p>Pod 内存使用率的计算就简单多了，直接用内存实际使用量除以内存限制使用量即可：</p><pre class="line-numbers language-none"><code class="language-none">sum(container_memory_rss{image!=""}) by(pod_name, namespace) / sum(container_spec_memory_limit_bytes{image!=""}) by(pod_name, namespace) * 100 != +inf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5、Pod-文件系统使用量"><a href="#5、Pod-文件系统使用量" class="headerlink" title="5、Pod 文件系统使用量"></a>5、Pod 文件系统使用量</h3><pre class="line-numbers language-none"><code class="language-none">sum(container_fs_usage_bytes{image!=""}) by(pod_name, namespace) / 1024 / 1024 / 1024<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6、Prometheus-pod-流量监控"><a href="#6、Prometheus-pod-流量监控" class="headerlink" title="6、Prometheus pod 流量监控"></a>6、Prometheus pod 流量监控</h3><h4 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1 问题描述"></a>1 问题描述</h4><p>监控某个服务对应 pod 的流量，将 pod 的流量呈现在 dashboard 上，并且作为监控告警的依据。</p><h4 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2 解决办法"></a>2 解决办法</h4><p>kube-state-metrics 是 K8S 官方项目，会采集pod、deployment等资源的元信息。使用 container_network_receive_bytes_total container_network_transmit_bytes_total 来检索进出 pod 的流量。由于 pod 可能会重启，这样检索出来的数据可能会分成多个段，可以简单的使用 sum 这样的函数来聚合。<br>2.1 查询语句</p><p>完整的检索语句：</p><pre class="line-numbers language-none"><code class="language-none">label_replace(sum by (node)(irate(container_network_receive_bytes_total{pod_name=~"x-service-.*", interface="eth3"}[1m])), "service", "x-service", "", "" )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>irate(container_network_receive_bytes_total{pod_name=~”x-service-.*”, interface=”eth3”}[1m]) : 计算 x-service 这个服务 eth3 网口的进流量。</li><li>sum by (node)(irate(container_network_receive_bytes_total{pod_name=~”x-service-.*”, interface=”eth3”}[1m])) ： 对应 pod 重启的情况，将重启前后多个 pod 的数据做聚合。</li><li>label_replace ：用来给查询出来的数据添加 service:x-service 的标签。</li></ul><p><img src="https://raw.githubusercontent.com/realzhangqingwei/realzhangqingwei.github.io/master/imgs_for_blogs/20220417152731.png" alt="20220417152731"></p><h2 id="四、-参考链接"><a href="#四、-参考链接" class="headerlink" title="四、  参考链接"></a>四、  参考链接</h2><p>1、<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8b4cb143d174">通过Prometheus查询计算Kubernetes集群中Pod 的CPU、内存使用率等指标</a></p><p>2、<a target="_blank" rel="noopener" href="https://blog.csdn.net/doyzfly/article/details/113663980">Prometheus pod 流量监控</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> docker </tag>
            
            <tag> 容器 </tag>
            
            <tag> 监控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vscode两步搭建图床</title>
      <link href="/legend-blog/2022/04/17/2022-04-17-VS%20Code%E4%B8%A4%E6%AD%A5%E6%90%AD%E5%BB%BAgithub%E5%9B%BE%E5%BA%8A/"/>
      <url>/legend-blog/2022/04/17/2022-04-17-VS%20Code%E4%B8%A4%E6%AD%A5%E6%90%AD%E5%BB%BAgithub%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/legend-blog/assets/css/APlayer.min.css"><script src="/legend-blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><a href="">https://mp.weixin.qq.com/s/2HnFrcwxHr5g2VvRB2N_JQ</a></p></blockquote><h2 id="一、最终效果"><a href="#一、最终效果" class="headerlink" title="一、最终效果"></a>一、最终效果</h2><p>VS Code中，可以 <strong>实现图片的一键上传和引用返回</strong> 。免费图床，简单好用～</p><h2 id="二、写在前面"><a href="#二、写在前面" class="headerlink" title="二、写在前面"></a>二、写在前面</h2><p>之前用的某个图床( <strong>就不说名字了</strong> )，今天支持明天不支持，写的博客直接废了，让博主痛不欲生。</p><p>有的网站，强制给本地上传的图片加水印，丑死了。</p><p>痛定思痛决定搭建个github的图床，没想到这么简单就搞定了～</p><h3 id="1-VScode插件PicGo"><a href="#1-VScode插件PicGo" class="headerlink" title="1. VScode插件PicGo"></a>1. VScode插件PicGo</h3><p>需要用到Picgo这个插件，直接在vscode中搜索安装就行。</p><h3 id="2-PicGo的Github配置"><a href="#2-PicGo的Github配置" class="headerlink" title="2. PicGo的Github配置"></a>2. PicGo的Github配置</h3><p>打开设置，找到extensions中的Picgo的设置</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/KxvDktg1OnYrV4ia3Uxo26AwBCbL6tFmlKC9PIGWnyGFpV18LGJNtewA2nRWCn323sGIpXNzyTVlt216rIqU87Q/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>往下拖找到github，进行配置:</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/KxvDktg1OnYrV4ia3Uxo26AwBCbL6tFmlnzohrdyQge2ibaJFKWfLBeEzRtlnv5s6wYbjB8TxorASEMe2MobBxgw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>首先是PicGo-Core设为</p><pre class="line-numbers language-none"><code class="language-none">github<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Branch自己用git命令</p><pre class="line-numbers language-none"><code class="language-none">`git branch -a`<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看自己的branch，我就一个master，所以填的master</p><p>Path要和Repo搭配使用，到时候上传的图片就会到<strong>Repo+Path</strong>目录下，比如我的会传到：</p><pre class="line-numbers language-none"><code class="language-none">`wyl6/wyl6.github.io/imgs_for_blogs/`<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面，所以并不需要单独开个repo，加个目录就行。</p><p>注意，Path后面加”/“，不然后面一部分会当成图片名称合并进去。比如Path设为：</p><pre class="line-numbers language-none"><code class="language-none">`imgs_for_blogs/hello`<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那么上传world.png时图片会成为：</p><pre class="line-numbers language-none"><code class="language-none">`imgs_for_blogs/helloworld.png`<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后一步的token，从github上重新生成一个就行(token只出现一次，之前的几乎找不到)。首先从头像那打开设置:</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/KxvDktg1OnYrV4ia3Uxo26AwBCbL6tFml7T3sVWS3rL22SvWgTe1Qab9FnUhg71yEhYWx0GaKRzBR4wuuSL3W1g/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>找到最下面的Developer Settings:</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/KxvDktg1OnYrV4ia3Uxo26AwBCbL6tFmlBKkSuKqZDdoY9SVlePM1eUpy8DQYepTUnwkUuBibRMLIGhxDzY9gsNA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>从Personal Access里生成一个token，可以备份下次使用：<img src="https://mmbiz.qpic.cn/mmbiz_png/KxvDktg1OnYrV4ia3Uxo26AwBCbL6tFmlGoOAd8LfCZdux42AjYZSNVfydKcTBOP5U7qWKqomT1xYZRHUju5Uxg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>最后把token复制到PicGo设置里的Github Token里就行。然后就可以在vscode里使用图床了。</p><p>备注: 另外一种配置方法如下<br><img src="https://github.com/realzhangqingwei/legend-blog/source/_posts/This-is-a-test-blog/20220418211232.png" alt="20220418211232"></p><h3 id="3-图床命令"><a href="#3-图床命令" class="headerlink" title="3.图床命令"></a>3.图床命令</h3><p>三个简要命令：</p><h4 id="1-、-ctrl-alt-e"><a href="#1-、-ctrl-alt-e" class="headerlink" title="(1)、 ctrl+alt+e"></a>(1)、 <code>ctrl+alt+e</code></h4><p>从文件目录手动插入图片</p><h4 id="2-、ctrl-alt-u"><a href="#2-、ctrl-alt-u" class="headerlink" title="(2)、ctrl+alt+u"></a>(2)、<code>ctrl+alt+u</code></h4><p>从剪贴板插入图片</p><h4 id="3-、ctrl-alt-o"><a href="#3-、ctrl-alt-o" class="headerlink" title="(3)、ctrl+alt+o"></a>(3)、<code>ctrl+alt+o</code></h4><p>从输入目录插入图片，相对目录和绝对目录都行</p><h4 id="4-、-常用快捷键如下"><a href="#4-、-常用快捷键如下" class="headerlink" title="(4)、 常用快捷键如下"></a>(4)、 常用快捷键如下</h4><blockquote><p>从命令看，说一键不太准确，也就两三键吧。<br><img src="https://raw.githubusercontent.com/realzhangqingwei/realzhangqingwei.github.io/master/imgs_for_blogs/20220417103853.png" alt="20220417103853"></p></blockquote><h3 id="四、-参考链接"><a href="#四、-参考链接" class="headerlink" title="四、  参考链接"></a>四、  参考链接</h3><p><a href=""></a><a href="">https://mp.weixin.qq.com/s/2HnFrcwxHr5g2VvRB2N_JQ</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Vscode </tag>
            
            <tag> 扩展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python和Go语言实现防火墙封堵IP</title>
      <link href="/legend-blog/2022/04/17/2022-04-17-Python%E5%92%8CGo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E9%98%B2%E7%81%AB%E5%A2%99%E5%B0%81%E5%A0%B5IP/"/>
      <url>/legend-blog/2022/04/17/2022-04-17-Python%E5%92%8CGo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E9%98%B2%E7%81%AB%E5%A2%99%E5%B0%81%E5%A0%B5IP/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/legend-blog/assets/css/APlayer.min.css"><script src="/legend-blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、目的"><a href="#一、目的" class="headerlink" title="一、目的"></a>一、目的</h2><p>使用Ensp搭建网络设备环境, 并用python和Go脚本实现批量封堵IP,  把重复繁琐的工作简单化.</p><h2 id="二、Ensp环境"><a href="#二、Ensp环境" class="headerlink" title="二、Ensp环境"></a>二、Ensp环境</h2><h3 id="1、-使用ensp的云-并且防火墙配置了ssh服务"><a href="#1、-使用ensp的云-并且防火墙配置了ssh服务" class="headerlink" title="1、 使用ensp的云, 并且防火墙配置了ssh服务"></a>1、 使用ensp的云, 并且防火墙配置了ssh服务</h3><h3 id="2、拓扑图如下"><a href="#2、拓扑图如下" class="headerlink" title="2、拓扑图如下"></a>2、拓扑图如下</h3><p><img src="https://raw.githubusercontent.com/realzhangqingwei/realzhangqingwei.github.io/master/imgs_for_blogs/20220417154718.png" alt="20220417154718"></p><h2 id="三、python版本实现IP地址批量封堵"><a href="#三、python版本实现IP地址批量封堵" class="headerlink" title="三、python版本实现IP地址批量封堵"></a>三、python版本实现IP地址批量封堵</h2><pre class="line-numbers language-none"><code class="language-none">from netmiko import ConnectHandler, NetmikoTimeoutException, NetmikoAuthenticationExceptionfrom multiprocessing import Processfrom datetime import datetimeimport loggingimport argparse# import prettyimport osimport sys########################################################################################COMMANDS_LIST = [    "system-view", "dis version", "ip address-set 20220223 type object", "display ip address-set verbose  20220223 item"]def parse_args():    """    参数化构建程序    """    parser = argparse.ArgumentParser(description='Re-evaluate results')    parser.add_argument('output_dir', nargs=1, help='results directory',                        type=str)    parser.add_argument('--imdb', dest='imdb_name',                        help='dataset to re-evaluate',                        default='voc_2007_test', type=str)    parser.add_argument('--comp', dest='comp_mode', help='competition mode',                        action='store_true')    if len(sys.argv) == 1:        parser.print_help()        sys.exit(1)    args = parser.parse_args()    return argslogging.basicConfig(level=logging.DEBUG, filename="test.log")logger = logging.getLogger("netmiko")def show_version(a_device):    '''    Execute dis version command using Netmiko    '''    creds = a_device['credentials']    remote_conn = ConnectHandler(device_type=a_device['device_type'],                                 ip=a_device['ip_address'],                                 username=creds['username'],                                 password=creds['password'],                                 port=a_device['port'],                                 allow_auto_change=True,                                 auth_timeout=50,                                 secret='')    remote_conn.enable()    remote_conn.find_prompt()    # remote_conn.send_command("dis cu")    try:        print("开始批量执行IP地址封堵,解封动作.")        remote_conn.send_config_from_file("BlockCmd.txt")    except Exception as e:        print("批量执行IP地址封堵,解封动作, 产生的告警信息是: %s." % e)def Cmd_List():    CmdList = []    CmdList.append("ip address-set 20220223 type object" + "\n")    # 下面是封堵IP的案例的组装命令案例    with open("BlockIp.txt", "r+") as f1:        with open("BlockCmd.txt", "w+") as f2:            for ip in f1:                cmd = "address" + " " + \                    ip.strip().split("/")[0] + " " + \                    "mask" + " " + ip.strip().split("/")[1]                CmdList.append(cmd + "\n")            f2.writelines(CmdList)    # 以下是解封IP的案例, 组装命令, 范围就是解封多少条.    # with open("BlockCmd.txt", "w+") as f2:    #         for ip in range(0, 1000):    #             cmd = "undo" + " " + "address" + " " + str(ip)    #             CmdList.append(cmd + "\n")    #         f2.writelines(CmdList)def main():    '''    Use processes and Netmiko to connect to each of the devices in the database. Execute    'dis version' on each device. Record the amount of time required to do this.    '''    Cmd_List()    start_time = datetime.now()    # 新增设备, 增加字典    devices = [{'device_type': 'huawei',               'ip_address': '192.168.0.35',                'credentials': {'username': 'hcnp',                                'password':  'hcnp@12345',                                },                'port': 6000,                'secret': '',                },               ]    procs = []    for a_device in devices:        # show_version(a_device)        my_proc = Process(target=show_version, args=(a_device,))        my_proc.start()        procs.append(my_proc)    for a_proc in procs:        print(a_proc)        a_proc.join()    print("\nElapsed time: " + str(datetime.now() - start_time))if __name__ == "__main__":    # args = parse_args()    # print(args)     main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、Go版本实现IP地址封堵"><a href="#四、Go版本实现IP地址封堵" class="headerlink" title="四、Go版本实现IP地址封堵"></a>四、Go版本实现IP地址封堵</h2><pre class="line-numbers language-none"><code class="language-none">package mainimport ("bufio""fmt""log""os""sync""golang.org/x/crypto/ssh")//获取账号和密码的对应关系type HostPassword struct {Host     stringUsername stringPassword stringPort     string}var (commands = []string{}   //执行命令组hp       []HostPassword //保存账号和密码wg       sync.WaitGroup //执行goroutine, 确保goroutine执行完输出到屏幕)func main() {//1. 选择操作交换机// 1.1 输入要执行交换机// 创建结构体类型切片, 本次只操作一个主机, 更改长度可操作多个网络设备hp = make([]HostPassword, 1)hp[0] = HostPassword{Host: "192.168.0.35", Username: "hcnp", Password: "hcnp@12345", Port: "6000"}fmt.Println("组装的hp信息是: ", hp)// 1.2 输入要执行的初始化命令, 顺便把命令也带进去commands = append(commands, "dis version\n", "system-view\n", "ip address-set 20220223 type object\n")file, err := os.Open("BlockCmd.txt")if err != nil {log.Fatalf("Error when opening file: %s", err)}fileScanner := bufio.NewScanner(file)for fileScanner.Scan() {commands = append(commands, fileScanner.Text()+"\n")}if err := fileScanner.Err(); err != nil {log.Fatalf("Error while reading file: %s", err)}file.Close()fmt.Println(commands)//2. 执行交换机操作errors := SshSwitch(hp)if errors != nil {log.Fatalln(errors)}// 同步等待, 是把结果输出到屏幕wg.Wait()}//建立ssh连接func SshSwitch(hostpasswords []HostPassword) error {//循环获取hostpasswords的账号和密码for i, _ := range hp {//添加同步组，下面会执行goroutinwg.Add(1)config := &amp;ssh.ClientConfig{Config: ssh.Config{Ciphers: []string{"aes128-ctr", "aes192-ctr", "aes256-ctr", "aes128-gcm@openssh.com", "arcfour256", "arcfour128", "aes128-cbc", "3des-cbc", "aes192-cbc", "aes256-cbc"},}, //添加了很多加密方式，为了应对不同的密码规则User: hp[i].Username,Auth: []ssh.AuthMethod{ssh.Password(hp[i].Password),},HostKeyCallback: ssh.InsecureIgnoreHostKey(), //此处相当于执行nil，但是并不安全}addr := fmt.Sprintf("%s:%s", hp[i].Host, hp[i].Port) //组合主机名和端口client, err := ssh.Dial("tcp", addr, config)if err != nil {log.Fatalln("建立ssh连接错误:", err)return err}//执行goroutine，但是没有返回错误。go HandleSession(client, commands, &amp;wg)}return nil}//建立session，执行命令。func HandleSession(client *ssh.Client, commands []string, wg *sync.WaitGroup) error {//建立sessionsession, err := client.NewSession()if err != nil {log.Fatalln("创建session出错", err)return err}//延迟关闭sessiondefer session.Close()//设置terminalmodes的方式modes := ssh.TerminalModes{ssh.ECHO:          0,     // disable echoingssh.TTY_OP_ISPEED: 14400, // input speed = 14.4kbaudssh.TTY_OP_OSPEED: 14400, // output speed = 14.4kbaud}//建立伪终端err = session.RequestPty("xterm", 80, 40, modes)if err != nil {log.Fatal("创建requestpty出错", err)return err}//设置session的标准输入是stdinstdin, err := session.StdinPipe()if err != nil {log.Fatal("输入错误", err)return err}//设置session的标准输出和错误输出分别是os.stdout,os,stderr.就是输出到后台session.Stdout = os.Stdoutsession.Stderr = os.Stderrerr = session.Shell()if err != nil {log.Fatal("创建shell出错", err)return err}//将命令依次执行for _, cmd := range commands {fmt.Println(cmd)_, err = fmt.Fprintf(stdin, "%s\n", cmd)if err != nil {log.Fatal("写入stdin出错", err)return err}}//执行等待err = session.Wait()if err != nil {log.Fatal("等待session出错", err)return err}// 退出ssherr = session.Close()if err != nil {log.Fatal("关闭出错", err)return err}//减少同步组的次数wg.Done()return nil}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>使用中发现, Go语言的速度比Python快很多, 毕竟python是胶水语言, Go才是未来.</p><h2 id="六、-参考链接"><a href="#六、-参考链接" class="headerlink" title="六、  参考链接"></a>六、  参考链接</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Go </tag>
            
            <tag> 华为 </tag>
            
            <tag> 网络设备 </tag>
            
            <tag> 防火墙 </tag>
            
            <tag> Ensp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为防火墙通过地址集封堵IP</title>
      <link href="/legend-blog/2022/04/17/2022-04-17-%E5%8D%8E%E4%B8%BA%E9%98%B2%E7%81%AB%E5%A2%99%E9%80%9A%E8%BF%87%E5%9C%B0%E5%9D%80%E9%9B%86%E5%B0%81%E5%A0%B5IP/"/>
      <url>/legend-blog/2022/04/17/2022-04-17-%E5%8D%8E%E4%B8%BA%E9%98%B2%E7%81%AB%E5%A2%99%E9%80%9A%E8%BF%87%E5%9C%B0%E5%9D%80%E9%9B%86%E5%B0%81%E5%A0%B5IP/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/legend-blog/assets/css/APlayer.min.css"><script src="/legend-blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、目的"><a href="#一、目的" class="headerlink" title="一、目的"></a>一、目的</h2><p>在华为防火墙中, 使用地址集封堵IP</p><h2 id="二、实验过程"><a href="#二、实验过程" class="headerlink" title="二、实验过程"></a>二、实验过程</h2><h3 id="1、创建地址集"><a href="#1、创建地址集" class="headerlink" title="1、创建地址集"></a>1、创建地址集</h3><pre class="line-numbers language-none"><code class="language-none">#ip address-set 20220223 type object address  1.1.1.1 mask 32<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2、创建安全策略并把地址集加进去"><a href="#2、创建安全策略并把地址集加进去" class="headerlink" title="2、创建安全策略并把地址集加进去"></a>2、创建安全策略并把地址集加进去</h3><pre class="line-numbers language-none"><code class="language-none">security-policy rule name 20220223  source-address address-set 20220223  action deny<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、验证"><a href="#3、验证" class="headerlink" title="3、验证"></a>3、验证</h3><p><img src="https://raw.githubusercontent.com/realzhangqingwei/realzhangqingwei.github.io/master/imgs_for_blogs/20220417144328.png" alt="20220417144328"></p><p><img src="https://raw.githubusercontent.com/realzhangqingwei/realzhangqingwei.github.io/master/imgs_for_blogs/20220417144405.png" alt="20220417144405"></p><p><img src="https://raw.githubusercontent.com/realzhangqingwei/realzhangqingwei.github.io/master/imgs_for_blogs/20220417144443.png" alt="20220417144443"></p><h2 id="四、-参考链接"><a href="#四、-参考链接" class="headerlink" title="四、  参考链接"></a>四、  参考链接</h2><p>1、<a target="_blank" rel="noopener" href="https://support.huawei.com/">华为官网</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 华为 </tag>
            
            <tag> 网络设备 </tag>
            
            <tag> 防火墙 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux根扩容(基于LVM)</title>
      <link href="/legend-blog/2022/04/17/2022-04-18-%E5%9F%BA%E4%BA%8ELVM%E7%BB%99Linux%E6%A0%B9%E6%89%A9%E5%AE%B9/"/>
      <url>/legend-blog/2022/04/17/2022-04-18-%E5%9F%BA%E4%BA%8ELVM%E7%BB%99Linux%E6%A0%B9%E6%89%A9%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/legend-blog/assets/css/APlayer.min.css"><script src="/legend-blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、目的"><a href="#一、目的" class="headerlink" title="一、目的"></a>一、目的</h2><h3 id="1、通过LVM的方式给Linux系统扩容-可以达到提升系统的容量-并且可以提升系统的性能"><a href="#1、通过LVM的方式给Linux系统扩容-可以达到提升系统的容量-并且可以提升系统的性能" class="headerlink" title="1、通过LVM的方式给Linux系统扩容, 可以达到提升系统的容量, 并且可以提升系统的性能."></a>1、通过LVM的方式给Linux系统扩容, 可以达到提升系统的容量, 并且可以提升系统的性能.</h3><h3 id="2、这里是添加20G的盘-盘要是lvm格式，可用lvdisplay查看"><a href="#2、这里是添加20G的盘-盘要是lvm格式，可用lvdisplay查看" class="headerlink" title="2、这里是添加20G的盘, 盘要是lvm格式，可用lvdisplay查看"></a>2、这里是添加20G的盘, 盘要是lvm格式，可用lvdisplay查看</h3><h2 id="二、操作步骤"><a href="#二、操作步骤" class="headerlink" title="二、操作步骤"></a>二、操作步骤</h2><h3 id="1、通过存储系统给Linux系统增加磁盘"><a href="#1、通过存储系统给Linux系统增加磁盘" class="headerlink" title="1、通过存储系统给Linux系统增加磁盘"></a>1、通过存储系统给Linux系统增加磁盘</h3><p>说明: 可以通过Glusterfs, ceph等存储集群, 给弹性云主机添加磁盘.</p><h3 id="2、查看添加的磁盘"><a href="#2、查看添加的磁盘" class="headerlink" title="2、查看添加的磁盘"></a>2、查看添加的磁盘</h3><p><img src="https://raw.githubusercontent.com/realzhangqingwei/realzhangqingwei.github.io/master/imgs_for_blogs/20220417114135.png" alt="20220417114135"></p><h3 id="3、新增加的磁盘进行分区"><a href="#3、新增加的磁盘进行分区" class="headerlink" title="3、新增加的磁盘进行分区"></a>3、新增加的磁盘进行分区</h3><pre class="line-numbers language-none"><code class="language-none">fdisk /dev/sdc添加一个新的主分区n-p-w<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/realzhangqingwei/realzhangqingwei.github.io/master/imgs_for_blogs/20220417114345.png" alt="20220417114345"></p><h3 id="4、磁盘进行格式化"><a href="#4、磁盘进行格式化" class="headerlink" title="4、磁盘进行格式化"></a>4、磁盘进行格式化</h3><p><img src="https://raw.githubusercontent.com/realzhangqingwei/realzhangqingwei.github.io/master/imgs_for_blogs/20220417114443.png" alt="20220417114443"></p><h3 id="5、创建PV"><a href="#5、创建PV" class="headerlink" title="5、创建PV"></a>5、创建PV</h3><pre class="line-numbers language-none"><code class="language-none">pvcreate /dev/sdc1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/realzhangqingwei/realzhangqingwei.github.io/master/imgs_for_blogs/20220417114533.png" alt="20220417114533"></p><h3 id="6、创建VG"><a href="#6、创建VG" class="headerlink" title="6、创建VG"></a>6、创建VG</h3><pre class="line-numbers language-none"><code class="language-none">lvsvgextend centos  /dev/sdc1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/realzhangqingwei/realzhangqingwei.github.io/master/imgs_for_blogs/20220417114753.png" alt="20220417114753"></p><h3 id="7、pvs查看一下有多少空余"><a href="#7、pvs查看一下有多少空余" class="headerlink" title="7、pvs查看一下有多少空余"></a>7、pvs查看一下有多少空余</h3><p><img src="https://raw.githubusercontent.com/realzhangqingwei/realzhangqingwei.github.io/master/imgs_for_blogs/20220417114836.png" alt="20220417114836"></p><h3 id="8、lv扩展"><a href="#8、lv扩展" class="headerlink" title="8、lv扩展"></a>8、lv扩展</h3><pre class="line-numbers language-none"><code class="language-none">lvextend -L +19G /dev/centos/root<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/realzhangqingwei/realzhangqingwei.github.io/master/imgs_for_blogs/20220417114922.png" alt="20220417114922"></p><h3 id="9、查看lvs"><a href="#9、查看lvs" class="headerlink" title="9、查看lvs"></a>9、查看lvs</h3><p><img src="https://raw.githubusercontent.com/realzhangqingwei/realzhangqingwei.github.io/master/imgs_for_blogs/20220417114951.png" alt="20220417114951"></p><h3 id="10、检查分区（可有可无）"><a href="#10、检查分区（可有可无）" class="headerlink" title="10、检查分区（可有可无）"></a>10、检查分区（可有可无）</h3><pre class="line-numbers language-none"><code class="language-none">e2fsck -f /dev/centos/root<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/realzhangqingwei/realzhangqingwei.github.io/master/imgs_for_blogs/20220417115051.png" alt="20220417115051"></p><h3 id="11、-调整分区（在-x2F-etc-x2F-fstab中查看）"><a href="#11、-调整分区（在-x2F-etc-x2F-fstab中查看）" class="headerlink" title="11、 调整分区（在/etc/fstab中查看）"></a>11、 调整分区（在/etc/fstab中查看）</h3><pre class="line-numbers language-none"><code class="language-none">resize2fs /dev/vgtest/lvtest   #ext4格式的xfs_growfs /dev/centos/root    #xfs格式的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/realzhangqingwei/realzhangqingwei.github.io/master/imgs_for_blogs/20220417115203.png" alt="20220417115203"></p><h3 id="12、查看"><a href="#12、查看" class="headerlink" title="12、查看"></a>12、查看</h3><pre class="line-numbers language-none"><code class="language-none">df -h<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="13、查看剩余"><a href="#13、查看剩余" class="headerlink" title="13、查看剩余"></a>13、查看剩余</h3><p>重复第七步到第十二步</p><h3 id="14、重新挂载（可有可无）"><a href="#14、重新挂载（可有可无）" class="headerlink" title="14、重新挂载（可有可无）"></a>14、重新挂载（可有可无）</h3><pre class="line-numbers language-none"><code class="language-none">mount /dev/vgtest/lvtest /123----<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="三、-参考资料"><a href="#三、-参考资料" class="headerlink" title="三、 参考资料"></a>三、 参考资料</h2><p>1、<a target="_blank" rel="noopener" href="https://serverfault.com/questions/917650/vgextend-device-excluded-by-a-filter">pvcreate : “device excluded by a filter”</a></p><p>2、<a target="_blank" rel="noopener" href="https://unix.stackexchange.com/questions/465719/vgextend-fail-on-couldnt-create-temporary-archive-name">vgextend fail on Couldn't create temporary archive name</a></p><p>3、<a target="_blank" rel="noopener" href="https://serverfault.com/questions/934024/logical-volume-dev-centos-root-is-extended-but-dev-mapper-centos-root-is-not">Logical Volume /dev/centos/root is extended but /dev/mapper/centos-root is not</a></p><p>4、<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b41c7b2fffe1">Linux LVM扩</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> CentOS </tag>
            
            <tag> 根扩容 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Hexo】使用Hexo+github pages+travis ci搭建好看的个人博客（三）</title>
      <link href="/legend-blog/2020/05/04/hexo-theme/"/>
      <url>/legend-blog/2020/05/04/hexo-theme/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/legend-blog/assets/css/APlayer.min.css"><script src="/legend-blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>前两篇文章介绍了 <code>Hexo</code> + <code>github pages</code> + <code>travis ci</code> 进行自动化部署，并介绍了 <code>Hexo</code> 的配置文件中的各个属性，相信通过前两篇文章的学习，你已经学会了如何搭建自己的博客，并能够根据自己的需要进行个性化配置。</p><p>这一篇将以 <code>Matery</code> 这款主题为例，说明一下主题应该如何配置。包括主题配置、插件设置、注意事项等。</p><h2 id="设置博客主题"><a href="#设置博客主题" class="headerlink" title="设置博客主题"></a>设置博客主题</h2><p>先到<a target="_blank" rel="noopener" href="https://hexo.io/themes/">这里</a> 选择你喜欢的主题，点击它的标题（注意，点图片是进去 <em>demo</em> 站点，点标题才是跳转到对应到 <em>github</em> 仓库），跳转到 <em>github</em> 仓库，复制其仓库地址。</p><p>比如我使用到主题是 <code>Matery</code> ，其项目地址为：<code>git@github.com:blinkfox/hexo-theme-matery.git</code>。</p><p>打开本地目录，来到与我们的博客项目同级的目录（注意是同级，不是在博客项目内部），将主题项目克隆到本地。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git clone git@github.com:blinkfox/hexo-theme-matery.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在博客项目下的 <em>themes</em> 文件夹里新建一个叫 <em>matery</em> 的文件夹，然后将主题文件复制到这个文件夹里：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir breeze-blog/themes/materycp -r hexo-theme-matery/* breeze-blog/themes/matery<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里的 <em>breeze-blog</em> 是我的博客项目所在的文件夹，这里替换成你的即可。</p><p>再次打开我们的配置文件(<em>_config.yml</em>)，修改 <em>theme</em> 属性，设置为博客主题所在的文件夹名，这里即为 <em>matery</em>，注意要与文件夹名称完全一致。</p><p>然后我们重新生成一下博客静态文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd breeze-bloghexo clean &amp;&amp; hexo generatehexo server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后再打开我们的博客地址：<code>localhost:4000</code>，我们的主题便设置好了。</p><p><img src="https://i.loli.net/2020/05/04/YKwFax1NrtVL6Zo.jpg" alt="hexo-theme-1.jpg"></p><p>但现在大部分信息都是默认数据，所以我们需要根据需要进行自定义设置，不同主题的配置文件都不太一样，因此设置方法也有所不同，这里仅介绍 <code>Matery</code> 主题的设置方法。</p><h2 id="主题内容自定义"><a href="#主题内容自定义" class="headerlink" title="主题内容自定义"></a>主题内容自定义</h2><h3 id="新建页面"><a href="#新建页面" class="headerlink" title="新建页面"></a>新建页面</h3><p>如果你点击首页最上面的那一栏，会发现很多页面打开是没有的，因为我们还没有创建对应的页面，所以需要先创建对应的页面。</p><p><img src="https://i.loli.net/2020/05/04/9o7sjVdBMcm24TP.jpg" alt="hexo-theme-2.jpg"></p><p>先新建分类 <code>categories</code> 页，<code>categories</code> 页是用来展示所有分类的页面，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page "categories"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑新建的页面文件 <em>/source/categories/index.md</em>，写入以下内容：</p><pre class="line-numbers language-none"><code class="language-none">---title: categoriesdate: 2020-05-04 10:40:13type: "categories"layout: "categories"---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后新建标签 <code>tags</code> 页，<code>tags</code> 页是用来展示所有标签的页面，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page "tags"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑新建的页面文件 <em>/source/tags/index.md</em>，写入以下内容：</p><pre class="line-numbers language-none"><code class="language-none">---title: tagsdate: 2020-05-04 10:40:14type: "tags"layout: "tags"---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来是新建 <code>about</code> 页，<code>about</code> 页是用来展示关于我和我的博客信息的页面，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page "about"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑新建的页面文件 <code>/source/about/index.md</code>，写入以下内容：</p><pre class="line-numbers language-none"><code class="language-none">---title: aboutdate: 2020-05-04 10:40:15type: "about"layout: "about"---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后新建留言板 <code>contact</code> 页，<code>contact</code> 页是用来展示留言板信息的页面，方便其他人进行统一留言，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page "contact"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑新建的页面文件 <em>/source/contact/index.md</em>，写入以下内容：</p><pre class="line-numbers language-none"><code class="language-none">---title: contactdate: 2020-05-04 10:40:16type: "contact"layout: "contact"---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，留言板功能依赖于第三方评论系统，需要先激活评论系统才有效果，如果嫌麻烦不想使用，也可以不处理，后面在菜单栏里去掉这一选项即可。</p><p>最后，新建友情链接 <code>friends</code> 页，<code>friends</code> 页是用来展示友情链接信息的页面，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page "friends"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑新建的页面文件 <em>/source/friends/index.md</em>，写入以下内容：</p><pre class="line-numbers language-none"><code class="language-none">---title: friendsdate: 2020-05-04 10:40:17type: "friends"layout: "friends"---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时，在你的博客 <code>source</code> 目录下新建 <em>_data</em> 目录，在 <em>_data</em> 目录中新建 <em>friends.json</em> 文件，文件内容如下所示：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">[{    "avatar": "https://mfrank2016.github.io/breeze-blog/medias/avatar.jpg",    "name": "清风",    "introduction": "技术博主，文章还不错",    "url": "https://mfrank2016.github.io/breeze-blog/",    "title": "前去学习"}, {    "avatar": "https://draveness.me/images/draven-logo.png",    "name": "真没什么逻辑",    "introduction": "面向信仰编程",    "url": "https://draveness.me/",    "title": "前去学习"}]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里可以根据需要进行删减，当然，要看效果可以先这样设置，之后再来修改也不迟。</p><p>新建完页面后，我们再重新生成一下博客静态页，然后运行一下项目，便能看到效果了。这里标签页和分类页都只会展示现有博客的标签和分类数据，所以如果还没有文章设置标题或者分类，那么对应页面是没有数据的。要想看到效果，就得先写几篇文章。</p><h3 id="菜单导航配置"><a href="#菜单导航配置" class="headerlink" title="菜单导航配置"></a>菜单导航配置</h3><h4 id="配置基本菜单导航的名称、路径url和图标icon"><a href="#配置基本菜单导航的名称、路径url和图标icon" class="headerlink" title="配置基本菜单导航的名称、路径url和图标icon."></a>配置基本菜单导航的名称、路径url和图标icon.</h4><p>1.菜单导航名称可以是中文也可以是英文(如：<code>Index</code>或<code>主页</code>) 2.图标icon 可以在<a target="_blank" rel="noopener" href="https://fontawesome.com/icons">Font Awesome</a> 中查找</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">menu:  Index:    url: /    icon: fas fa-home  Tags:    url: /tags    icon: fas fa-tags  Categories:    url: /categories    icon: fas fa-bookmark  Archives:    url: /archives    icon: fas fa-archive  About:    url: /about    icon: fas fa-user-circle  Friends:    url: /friends    icon: fas fa-address-book<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="二级菜单配置方法"><a href="#二级菜单配置方法" class="headerlink" title="二级菜单配置方法"></a>二级菜单配置方法</h4><p>如果你需要二级菜单则可以在原基本菜单导航的基础上如下操作<br>1.在需要添加二级菜单的一级菜单下添加<code>children</code>关键字(如:<code>About</code>菜单下添加<code>children</code>)<br>2.在<code>children</code>下创建二级菜单的 名称name,路径url和图标icon.<br>3.注意每个二级菜单模块前要加 <code>-</code>.<br>4.注意缩进格式</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">menu:  Index:    url: /    icon: fas fa-home  Tags:    url: /tags    icon: fas fa-tags  Categories:    url: /categories    icon: fas fa-bookmark  Archives:    url: /archives    icon: fas fa-archive  About:    url: /about    icon: fas fa-user-circle-o  Friends:    url: /friends    icon: fas fa-address-book  Medias:    icon: fas fa-list    children:      - name: Musics        url: /musics        icon: fas fa-music      - name: Movies        url: /movies        icon: fas fa-film      - name: Books        url: /books        icon: fas fa-book      - name: Galleries        url: /galleries        icon: fas fa-image<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后就可以在文章中对应位置看到你用<code>emoji</code>语法写的表情了。</p><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 <a target="_blank" rel="noopener" href="https://github.com/ele828/hexo-prism-plugin">hexo-prism-plugin</a> 的 Hexo 插件来做代码高亮，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm i -S hexo-prism-plugin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后，修改 Hexo 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并新增 <code>prism</code> 插件相关的配置，主要配置如下：</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">highlight:  enable: falseprism_plugin:  mode: 'preprocess'    # realtime/preprocess  theme: 'tomorrow'  line_number: false    # default false  custom_css:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>主题中还使用到了 <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search">hexo-generator-search</a> 的 Hexo 插件来做内容搜索，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install hexo-generator-search --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">search:  path: search.xml  field: post<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>效果图如下：</p><p><img src="https://i.loli.net/2020/05/04/RrE3pQdq9CmtcTP.jpg" alt="hexo-theme-3.jpg"></p><h3 id="中文链接转拼音（建议安装）"><a href="#中文链接转拼音（建议安装）" class="headerlink" title="中文链接转拼音（建议安装）"></a>中文链接转拼音（建议安装）</h3><p>如果你的文章名称是中文的，那么 <em>Hexo</em> 默认生成的永久链接也会有中文，这样不利于 <code>SEO</code>，且 <code>gitment</code> 评论对中文链接也不支持。我们可以用 <a target="_blank" rel="noopener" href="https://github.com/viko16/hexo-permalink-pinyin">hexo-permalink-pinyin</a> <em>Hexo</em> 插件使在生成文章时生成中文拼音的永久链接。</p><p>安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm i hexo-permalink-pinyin --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 <em>Hexo</em> 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">permalink_pinyin:  enable: true  separator: '-' # default: '-'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="文章字数统计插件（建议安装）"><a href="#文章字数统计插件（建议安装）" class="headerlink" title="文章字数统计插件（建议安装）"></a>文章字数统计插件（建议安装）</h3><p>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 <a target="_blank" rel="noopener" href="https://github.com/willin/hexo-wordcount">hexo-wordcount</a>插件。</p><p>安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm i --save hexo-wordcount<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后只需在本主题下的 <code>_config.yml</code> 文件中，将各个文章字数相关的配置激活即可：</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">postInfo:  date: true  update: true  wordCount: true # 设置文章字数统计为 true.  totalCount: true # 设置站点文章总字数统计为 true.  min2read: true # 阅读时长.  readCount: true # 阅读次数.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加emoji表情支持（可选的）"><a href="#添加emoji表情支持（可选的）" class="headerlink" title="添加emoji表情支持（可选的）"></a>添加emoji表情支持（可选的）</h3><p><em>Matery</em> 主题新增了对<code>emoji</code>表情的支持，使用到了 <a target="_blank" rel="noopener" href="https://npm.taobao.org/package/hexo-filter-github-emojis">hexo-filter-github-emojis</a> 的 Hexo 插件来支持 <code>emoji</code>表情的生成，把对应的<code>markdown emoji</code>语法（<code>::</code>,例如：<code>:smile:</code>）转变成会跳跃的<code>emoji</code>表情，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install hexo-filter-github-emojis --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 <em>Hexo</em> 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">githubEmojis:  enable: true  className: github-emoji  inject: true  styles:  customEmojis:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加-RSS-订阅支持（可选的）"><a href="#添加-RSS-订阅支持（可选的）" class="headerlink" title="添加 RSS 订阅支持（可选的）"></a>添加 RSS 订阅支持（可选的）</h3><p>主题中还使用到了 <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo-generator-feed">hexo-generator-feed</a> 的 Hexo 插件来做 <code>RSS</code>，安装命令如下：</p><pre class="line-numbers language-none"><code class="language-none">npm install hexo-generator-feed --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 <em>Hexo</em> 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">feed:  type: atom  path: atom.xml  limit: 20  hub:  content:  content_limit: 140  content_limit_delim: ' '  order_by: -date<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后在 <code>public</code> 文件夹中即可看到 <code>atom.xml</code> 文件，说明你已经安装成功了。</p><h3 id="添加-DaoVoice-在线聊天功能（可选的）"><a href="#添加-DaoVoice-在线聊天功能（可选的）" class="headerlink" title="添加 DaoVoice 在线聊天功能（可选的）"></a>添加 <a target="_blank" rel="noopener" href="http://www.daovoice.io/">DaoVoice</a> 在线聊天功能（可选的）</h3><p>前往 <a target="_blank" rel="noopener" href="http://www.daovoice.io/">DaoVoice</a> 官网注册并且获取 <code>app_id</code>，并将 <code>app_id</code> 填入主题的 <code>_config.yml</code> 文件中。</p><h3 id="添加-Tidio-在线聊天功能（可选的）"><a href="#添加-Tidio-在线聊天功能（可选的）" class="headerlink" title="添加 Tidio 在线聊天功能（可选的）"></a>添加 <a target="_blank" rel="noopener" href="https://www.tidio.com/">Tidio</a> 在线聊天功能（可选的）</h3><p>前往 <a target="_blank" rel="noopener" href="https://www.tidio.com/">Tidio</a> 官网注册并且获取 <code>Public Key</code>，并将 <code>Public Key</code> 填入主题的 <code>_config.yml</code> 文件中。</p><h3 id="修改社交链接"><a href="#修改社交链接" class="headerlink" title="修改社交链接"></a>修改社交链接</h3><p>在主题的 <code>_config.yml</code> 文件中，默认支持 <code>QQ</code>、<code>GitHub</code> 和邮箱等的配置，你可以在主题文件的 <code>/layout/_partial/social-link.ejs</code> 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码：</p><pre class="line-numbers language-none"><code class="language-none">&lt;% if (theme.socialLink.github) { %&gt;    &lt;a href="&lt;%= theme.socialLink.github %&gt;" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"&gt;        &lt;i class="fab fa-github"&gt;&lt;/i&gt;    &lt;/a&gt;&lt;% } %&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，社交图标（如：<code>fa-github</code>）你可以在 <a target="_blank" rel="noopener" href="https://fontawesome.com/icons">Font Awesome</a> 中搜索找到。以下是常用社交图标的标识，供你参考：</p><ul><li>Facebook: <code>fab fa-facebook</code></li><li>Twitter: <code>fab fa-twitter</code></li><li>Google-plus: <code>fab fa-google-plus</code></li><li>Linkedin: <code>fab fa-linkedin</code></li><li>Tumblr: <code>fab fa-tumblr</code></li><li>Medium: <code>fab fa-medium</code></li><li>Slack: <code>fab fa-slack</code></li><li>Sina Weibo: <code>fab fa-weibo</code></li><li>Wechat: <code>fab fa-weixin</code></li><li>QQ: <code>fab fa-qq</code></li><li>Zhihu: <code>fab fa-zhihu</code></li></ul><h3 id="修改打赏的二维码图片"><a href="#修改打赏的二维码图片" class="headerlink" title="修改打赏的二维码图片"></a>修改打赏的二维码图片</h3><p>在主题文件的 <code>source/medias/reward</code> 文件中，可以替换成你的微信和支付宝的打赏二维码图片。</p><h3 id="配置音乐播放器（可选的）"><a href="#配置音乐播放器（可选的）" class="headerlink" title="配置音乐播放器（可选的）"></a>配置音乐播放器（可选的）</h3><p>要支持音乐播放，在主题的 <code>_config.yml</code> 配置文件中激活music配置即可：</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml"># 是否在首页显示音乐music:  enable: true  title:         #非吸底模式有效    enable: true    show: 听听音乐  server: netease   #require music platform: netease, tencent, kugou, xiami, baidu  type: playlist    #require song, playlist, album, search, artist  id: 503838841     #require song id / playlist id / album id / search keyword  fixed: false      # 开启吸底模式  autoplay: false   # 是否自动播放  theme: '#42b983'  loop: 'all'       # 音频循环播放, 可选值: 'all', 'one', 'none'  order: 'random'   # 音频循环顺序, 可选值: 'list', 'random'  preload: 'auto'   # 预加载，可选值: 'none', 'metadata', 'auto'  volume: 0.7       # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效  listFolded: true  # 列表默认折叠<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>server</code>可选<code>netease</code>（网易云音乐），<code>tencent</code>（QQ音乐），<code>kugou</code>（酷狗音乐），<code>xiami</code>（虾米音乐），</p><p><code>baidu</code>（百度音乐）。</p><p><code>type</code>可选<code>song</code>（歌曲），<code>playlist</code>（歌单），<code>album</code>（专辑），<code>search</code>（搜索关键字），<code>artist</code>（歌手）</p><p><code>id</code>获取示例: 打开手机版网易云音乐，选择喜欢的歌单，然后点击分享</p></blockquote><p>我这里随便选了一个歌单，分享后的文字长这样：</p><blockquote><p>分享真咸鱼饼干的歌单《青年节：致逐梦人，有志者事竟成》<a target="_blank" rel="noopener" href="http://music.163.com/playlist/4965675848/1548006936/?userid=120124365">http://music.163.com/playlist/4965675848/1548006936/?userid=120124365</a> (@网易云音乐)</p></blockquote><p><code>4965675848</code> 这就是歌单的id，文件里默认设置的歌单其实也还不错，歌挺多的，所以如果没什么特殊要求，使用默认歌单也不错。</p><p>⚠️这里需要注意一点，如果你想要替换成自己的歌单时，会发现，后续歌单的更新是不会影响到它的，这也是我捣鼓半天才发现的，音乐插件使用的是 <em>Aplayer</em> 播放器，在 <em><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js">https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js</a></em> 这个文件里可以看到，数据是从这个接口获取的：<em><a target="_blank" rel="noopener" href="https://api.i-meto.com/meting/api?server=:server&amp;type=:type&amp;id=:id&amp;r=:r">https://api.i-meto.com/meting/api?server=:server&amp;type=:type&amp;id=:id&amp;r=:r</a></em>，猜测服务端是直接将获取到的榜单列表写进里数据库，但后续不会进行更新，所以导致无论多少次刷新，都只能获取第一次取到的数据。</p><p>所以有两种解决办法，第一种是创建新歌单，然后一次性添加足够多的歌，然后在配置文件中替换成你的歌单id，另一种是自己写一个网易云音乐歌单解析接口，来获取网易云音乐数据。我比较懒，所以选择了第一种方案，23333，还在充实歌单中。</p><h2 id="文章-Front-matter-介绍"><a href="#文章-Front-matter-介绍" class="headerlink" title="文章 Front-matter 介绍"></a>文章 Front-matter 介绍</h2><h3 id="Front-matter-选项详解"><a href="#Front-matter-选项详解" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h3><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><blockquote><p><strong>注意</strong>:</p><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图<strong>各有特色</strong>。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a target="_blank" rel="noopener" href="http://tool.oschina.net/encrypt?type=2">开源中国在线工具</a>、<a target="_blank" rel="noopener" href="http://encode.chahuo.com/">chahuo</a>、<a target="_blank" rel="noopener" href="http://tool.chinaz.com/tools/hash.aspx">站长工具</a>。</li><li>您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则</li></ol></blockquote><p>以下为文章的 <code>Front-matter</code> 示例。</p><p>最简示例</p><pre class="line-numbers language-none"><code class="language-none">---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>最全示例</p><pre class="line-numbers language-none"><code class="language-none">---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00author: 赵奇img: /source/images/xxx.jpgtop: truecover: truecoverImg: /images/1.jpgpassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags:  - Typora  - Markdown---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述大部分内容都来自主题说明文档，只是添加了一下我觉得需要注意的地方。这里还有一些没有说到到的属性，这配置文件里都有详细的介绍，确实不需要过多解释。</p><p>最后再介绍一下我折腾比较久的插件，valine 评价插件。</p><h2 id="Valine-评价插件"><a href="#Valine-评价插件" class="headerlink" title="Valine 评价插件"></a>Valine 评价插件</h2><p>插件主页：<em><a target="_blank" rel="noopener" href="https://valine.js.org/">https://valine.js.org/</a></em> ，上面有详细的介绍，可以查看<a target="_blank" rel="noopener" href="https://valine.js.org/quickstart.html">这里</a>，注册后，验证邮箱，绑定手机号，然后新建一个应用，获取到对应的 <code>AppId</code> 和 <code>AppKey</code>，然后写回到主题文件下到 <code>_config.yml</code> 文件里，但是要<strong>注意一点，不要直接使用国内版进行注册，而要用国际版，否则无法申请二级域名</strong>。</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">valine:  enable: true  appId: XXX  appKey: XXX  notify: true  verify: false  visitor: true  avatar: 'retro' # Gravatar style : mm/identicon/monsterid/wavatar/retro/hide  pageSize: 10  placeholder: 'Comment here' # Comment Box placeholder  background: /medias/comment_bg.png<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最新版的 <code>Valine</code> 已经移除了邮件通知功能。如果没有邮件通知，很可能别人评价之后，你却毫不知情，后续回复对方也收不到。因此，需要再配置一个插件来实现， ++<a target="_blank" rel="noopener" href="https://github.com/zhaojun1998/Valine-Admin++">https://github.com/zhaojun1998/Valine-Admin++</a> 。在配置这个插件之前，需要确保 <code>Valine</code> 可以正常工作，可以自己给自己评论一下进行测试。</p><p>配置好之后，别人在你的文章下评论后你便能收到邮件通知了。</p><p>至此，<code>Matery</code> 主题就搭建配置完成了，接下来就只需要安心写博客了～</p><p><img src="https://i.loli.net/2020/05/02/AfHOY5RXge9tlVo.png" alt="微信公众号"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境搭建 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Hexo】使用Hexo+github pages+travis ci搭建好看的个人博客（二）</title>
      <link href="/legend-blog/2020/05/03/hexo-config/"/>
      <url>/legend-blog/2020/05/03/hexo-config/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/legend-blog/assets/css/APlayer.min.css"><script src="/legend-blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>上一篇里，介绍了使用 <code>Hexo</code> + <code>github pages</code> + <code>travis ci</code> 实现自动化博客部署，我们已经收获了一个属于自己的博客，但现在还比较简陋，里面的设置信息都是默认的数据，所以我们需要把它们改成我们想要的内容。</p><p>所以这一篇里，主要介绍 <code>Hexo</code> 的配置文件如何设置。通过本篇的学习，你将知道 <code>Hexo</code> 配置文件的各个属性是什么意思，并给出我使用的配置，这样你就能随心所欲的进行配置了。</p><h2 id="站点信息"><a href="#站点信息" class="headerlink" title="站点信息"></a>站点信息</h2><p>先来看第一部分，站点信息的配置。先说明一下各个字段的含义：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td>网站标题</td></tr><tr><td>subtitle</td><td>网站副标题</td></tr><tr><td>description</td><td>网站描述，主要用于 SEO，告诉搜索引擎关于站点的简要信息</td></tr><tr><td>keywords</td><td>网站的关键词。使用半角逗号, 分隔多个关键词。</td></tr><tr><td>author</td><td>你的名字</td></tr><tr><td>language</td><td>网站使用的语言，常见的有 zh-Hans 、zh-CN 、 en</td></tr><tr><td>timezone</td><td>网站时区。默认使用本地时区。也可以指定其它时区，如 America/New_York, Japan, 和 UTC 。一般的，对于中国大陆地区可以使用 Asia/Shanghai。</td></tr></tbody></table><p>下面是我的配置，可以作为参考：</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml"># Sitetitle: 弗兰克的猫subtitle: '永远年轻，永远热泪盈眶'description: '铭记过去，拥抱未来，心中有梦，眼里有光'keywords: 生活,编程,阅读,音乐,电影author: 清风language: zh-CNtimezone: ''<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="网址信息"><a href="#网址信息" class="headerlink" title="网址信息"></a>网址信息</h2><p>网址信息配置主要是设置网站的地址和文章链接格式。</p><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>url</td><td>网址</td><td></td></tr><tr><td>root</td><td>网站根目录</td><td></td></tr><tr><td>permalink</td><td>文章的永久链接</td><td>格式:year/:month/:day/:title/</td></tr><tr><td>permalink_defaults</td><td>永久链接中各部分的默认值</td><td></td></tr><tr><td>pretty_urls</td><td>改写 permalink 的值来美化 URL</td><td></td></tr><tr><td>pretty_urls.trailing_index</td><td>是否在永久链接中保留尾部的 index.html，设置为 false 时去除</td><td>true</td></tr><tr><td>pretty_urls.trailing_html</td><td>是否在永久链接中保留尾部的 .html, 设置为 false 时去除 (对尾部的 index.html无效)</td><td>true</td></tr></tbody></table><p>例如：</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml"># 比如，一个页面的永久链接是 http://example.com/foo/bar/index.htmlpretty_urls:  trailing_index: false# 此时页面的永久链接会变为 http://example.com/foo/bar/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这里通常只需要修改 <code>url</code> 和 <code>root</code>，如果博客是使用 <code>github pages</code> 进行部署的，<code>url</code> 配置成对应的博客地址即可。这里需要注意的是 <code>root</code> 的值，如果是按照我们上一篇中的方式进行部署的，则需要把 <code>root</code> 的值设置为 <code>/项目名/</code>。</p><p>下面是我的配置：</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml"># URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://mfrank2016.github.io/root: /breeze-blog/permalink: :year/:month/:day/:title/permalink_defaults:pretty_urls:  trailing_index: true # Set to false to remove trailing 'index.html' from permalinks  trailing_html: true # Set to false to remove trailing '.html' from permalinks<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="目录信息"><a href="#目录信息" class="headerlink" title="目录信息"></a>目录信息</h2><p>目录信息是指定各类目录对应的位置，通常不需要修改。</p><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>source_dir</td><td>资源文件夹，这个文件夹用来存放博客 <code>md</code> 等文件。</td><td>source</td></tr><tr><td>public_dir</td><td>公共文件夹，这个文件夹用于存放生成的站点静态文件。</td><td>public</td></tr><tr><td>tag_dir</td><td>标签文件夹</td><td>tags</td></tr><tr><td>archive_dir</td><td>归档文件夹</td><td>archives</td></tr><tr><td>category_dir</td><td>分类文件夹</td><td>categories</td></tr><tr><td>code_dir</td><td><code>Include code</code> 文件夹，<code>source_dir</code> 下的子目录</td><td>downloads/code</td></tr><tr><td>i18n_dir</td><td>国际化（i18n）文件夹</td><td>:lang</td></tr><tr><td>skip_render</td><td>跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 <code>public</code> 目录中。您可使用 <code>glob</code> 表达式来匹配路径。</td><td></td></tr></tbody></table><p>例如：</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">skip_render: "mypage/**/*"# 将会直接将 `source/mypage/index.html` 和 `source/mypage/code.js` 不做改动地输出到 'public' 目录# 你也可以用这种方法来跳过对指定文章文件的渲染skip_render: "_posts/test-post.md"# 这将会忽略对 'test-post.md' 的渲染<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我的配置如下：</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml"># Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="文章配置"><a href="#文章配置" class="headerlink" title="文章配置"></a>文章配置</h2><p>这一部分是配置与文章相关的各类属性。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>new_post_name</code></td><td align="left">新文章的文件名称</td><td align="left">:title.md</td></tr><tr><td align="left"><code>default_layout</code></td><td align="left">预设布局</td><td align="left">post</td></tr><tr><td align="left"><code>auto_spacing</code></td><td align="left">在中文和英文之间加入空格</td><td align="left">false</td></tr><tr><td align="left"><code>titlecase</code></td><td align="left">把标题转换为 <code>title case</code></td><td align="left">false</td></tr><tr><td align="left"><code>external_link</code></td><td align="left">在新标签中打开链接</td><td align="left">true</td></tr><tr><td align="left"><code>external_link.enable</code></td><td align="left">在新标签中打开链接</td><td align="left"><code>true</code></td></tr><tr><td align="left"><code>external_link.field</code></td><td align="left">对整个网站（<code>site</code>）生效或仅对文章（<code>post</code>）生效</td><td align="left"><code>site</code></td></tr><tr><td align="left"><code>external_link.exclude</code></td><td align="left">需要排除的域名。主域名和子域名如 <code>www</code> 需分别配置</td><td align="left"><code>[]</code></td></tr><tr><td align="left"><code>filename_case</code></td><td align="left">把文件名称转换为 (1) 小写或 (2) 大写</td><td align="left">0</td></tr><tr><td align="left"><code>render_drafts</code></td><td align="left">显示草稿</td><td align="left">false</td></tr><tr><td align="left"><code>post_asset_folder</code></td><td align="left">启动 <code>Asset</code> 文件夹</td><td align="left">false</td></tr><tr><td align="left"><code>relative_link</code></td><td align="left">把链接改为与根目录的相对位址</td><td align="left">false</td></tr><tr><td align="left"><code>future</code></td><td align="left">显示未来的文章</td><td align="left">true</td></tr><tr><td align="left"><code>highlight</code></td><td align="left">代码块的设置</td><td align="left"></td></tr><tr><td align="left"><code>highlight.enable</code></td><td align="left">开启代码块高亮</td><td align="left"><code>true</code></td></tr><tr><td align="left"><code>highlight.auto_detect</code></td><td align="left">如果未指定语言，则启用自动检测</td><td align="left"><code>false</code></td></tr><tr><td align="left"><code>highlight.line_number</code></td><td align="left">显示行数</td><td align="left"><code>true</code></td></tr><tr><td align="left"><code>highlight.tab_replace</code></td><td align="left">用 n 个空格替换 <code>tabs</code>；如果值为空，则不会替换 <code>tabs</code></td><td align="left"><code>''</code></td></tr><tr><td align="left"><code>highlight.wrap</code></td><td align="left">把代码块用 `` 包裹</td><td align="left"><code>true</code></td></tr><tr><td align="left"><code>highlight.hljs</code></td><td align="left">为 highlight 的 css 文件中的类添加 <code>hljs-*</code> 前缀</td><td align="left"><code>false</code></td></tr></tbody></table><p><code>auto_spacing</code> 建议开启，这样的话看起来更美观，<code>titlecase</code> 是指关键单词首字母大写，如果不太清楚，可以看下面的说明：</p><blockquote><p>Titles should be written in title case. This means only using capital letters for the principal words. Articles, conjunctions, and prepositions do not get capital letters unless they start the title. For example:<br>The Last of the Mohicans </p></blockquote><p><code>post_asset_folder</code> 建议开启，这样会在生成新的文章时，同时会同一目录下生成同名文件夹，这样可以把该文章相关的图片等资源放进去，方便引用和管理。</p><p>下面是我的配置：</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">new_post_name: :title.md # File name of new postsdefault_layout: postauto_spacing: truetitlecase: false # Transform title into titlecaseexternal_link:  enable: true # Open external links in new tab  field: post # Apply to the whole site  exclude: ''filename_case: 0render_drafts: falsepost_asset_folder: truerelative_link: falsefuture: true# highlight:#   enable: true#   line_number: true#   auto_detect: false#   tab_replace: ''#   wrap: true#   hljs: falsehighlight:  enable: false# 代码高亮prism_plugin:  mode: 'preprocess'    # realtime/preprocess  theme: 'tomorrow'  line_number: false    # default false  custom_css:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我使用了另一个代码高亮插件，如果通常使用默认的 <code>hljs</code> 高亮即可。如果也想要使用这个插件，可以查看<a target="_blank" rel="noopener" href="https://github.com/ele828/hexo-prism-plugin">这里</a>，需要先进行安装：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm i -S hexo-prism-plugin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="分类和标签信息"><a href="#分类和标签信息" class="headerlink" title="分类和标签信息"></a>分类和标签信息</h2><p>这里配置的是别名，即映射信息，如果文章使用的是英文名分类，这里可以不用设置，如果使用了中文名分类，最好配置一些对应的英文名，否则在对应的分类链接中就会出现 <code>URL</code> 编码的中文，比如这样：</p><pre class="line-numbers language-none"><code class="language-none">http://localhost:4000/breeze-blog/categories/programming/life/%E6%B5%8B%E8%AF%95/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>default_category</code></td><td align="left">默认分类</td><td align="left"><code>uncategorized</code></td></tr><tr><td align="left"><code>category_map</code></td><td align="left">分类别名</td><td align="left"></td></tr><tr><td align="left"><code>tag_map</code></td><td align="left">标签别名</td><td align="left"></td></tr></tbody></table><p>我的配置如下：</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml"># Category &amp; Tagdefault_category: uncategorizedcategory_map:  编程: programming  生活: life  阅读: reading  随想: thoughts  理财: financetag_map:  敏捷开发: agile-development  环境搭建: environment-building<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="日期-x2F-时间格式"><a href="#日期-x2F-时间格式" class="headerlink" title="日期 / 时间格式"></a>日期 / 时间格式</h2><p><code>Hexo</code> 使用 <a target="_blank" rel="noopener" href="http://momentjs.com/">Moment.js</a> 来解析和显示时间。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>date_format</code></td><td align="left">日期格式</td><td align="left"><code>YYYY-MM-DD</code></td></tr><tr><td align="left"><code>time_format</code></td><td align="left">时间格式</td><td align="left"><code>HH:mm:ss</code></td></tr><tr><td align="left"><code>use_date_for_updated</code></td><td align="left">启用以后，如果 Front Matter 中没有指定 <code>updated</code>， <code>post.updated</code> 将会使用 <code>date</code> 的值而不是文件的创建时间。在 Git 工作流中这个选项会很有用</td><td align="left"><code>true</code></td></tr></tbody></table><p>我的配置如下：</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml"># Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss## Use post's date for updated date unless set in front-matteruse_date_for_updated: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分页信息"><a href="#分页信息" class="headerlink" title="分页信息"></a>分页信息</h2><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>per_page</code></td><td align="left">每页显示的文章量 (0 = 关闭分页功能)</td><td align="left"><code>10</code></td></tr><tr><td align="left"><code>pagination_dir</code></td><td align="left">分页目录</td><td align="left"><code>page</code></td></tr></tbody></table><p>我的配置如下：</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml"># Pagination## Set per_page to 0 to disable paginationper_page: 12pagination_dir: page<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="扩展信息"><a href="#扩展信息" class="headerlink" title="扩展信息"></a>扩展信息</h2><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>theme</code></td><td align="left">当前主题名称。值为<code>false</code>时禁用主题</td></tr><tr><td align="left"><code>theme_config</code></td><td align="left">主题的配置文件。在这里放置的配置会覆盖主题目录下的 <code>_config.yml</code> 中的配置</td></tr><tr><td align="left"><code>deploy</code></td><td align="left">部署部分的设置</td></tr><tr><td align="left"><code>meta_generator</code></td><td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#%E5%B1%9E%E6%80%A7">Meta generator</a> 标签。 值为 <code>false</code> 时 Hexo 不会在头部插入该标签</td></tr></tbody></table><p>这里设置 <code>theme</code> 即可开启对应的主题，具体如何设置会在后面的文章进行详细说明。</p><p><code>theme_config</code> 可以在这里配置主题文件里的各个参数进行覆盖，这样就不用维护两份 <code>config</code> 文件了，不过个人觉得还是不同主题文件使用不同配置文件比较好。</p><p><code>deploy</code> 是部署相关的配置，比如 <code>git</code> 部署，除此之外，还有很多其它部署姿势，比如：<code>Heroku</code>、<code>Netlify</code> 等，但都需要先安装对应的插件。</p><p>我的配置如下：</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml"># Extensionstheme: hexo-theme-matery# Deploymentdeploy:  type: 'git'  repo: git@github.com:MFrank2016/breeze-blog  branch: gh-pages<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="包括或不包括目录和文件"><a href="#包括或不包括目录和文件" class="headerlink" title="包括或不包括目录和文件"></a>包括或不包括目录和文件</h2><p>在 <code>Hexo</code> 配置文件中，通过设置 <code>include/exclude</code> 可以让 <code>Hexo</code> 进行处理或忽略某些目录和文件夹。可以使用 <a target="_blank" rel="noopener" href="https://github.com/isaacs/minimatch">glob 表达式</a> 对目录和文件进行匹配。</p><p><code>include</code> 和 <code>exclude</code> 选项都只能应用于 <code>source/</code> 文件夹, 但 <code>ignore</code> 选项可以应用于所有文件夹。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>include</code></td><td align="left"><code>Hexo</code> 默认会忽略隐藏文件和文件夹（包括名称以下划线和 <code>.</code> 开头的文件和文件夹，<code>Hexo</code> 的 <code>_posts</code> 和 <code>_data</code> 等目录除外）。通过设置此字段将使 Hexo 处理他们并将它们复制到 <code>source</code> 目录下。</td></tr><tr><td align="left"><code>exclude</code></td><td align="left"><code>Hexo</code> 会忽略这些文件和目录</td></tr><tr><td align="left"><code>ignore</code></td><td align="left">忽略文件或文件夹</td></tr></tbody></table><p>举例：</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml"># Include/Exclude Files/Foldersinclude:  - ".nojekyll"  # 包括 'source/css/_typing.css'  - "css/_typing.css"  # 包括 'source/_css/' 中的任何文件，但不包括子目录及其其中的文件。  - "_css/*"  # 包含 'source/_css/' 中的任何文件和子目录下的任何文件  - "_css/**/*"exclude:  # 不包括 'source/js/test.js'  - "js/test.js"  # 不包括 'source/js/' 中的文件、但包括子目录下的所有目录和文件  - "js/*"  # 不包括 'source/js/' 中的文件和子目录下的任何文件  - "js/**/*"  # 不包括 'source/js/' 目录下的所有文件名以 'test' 开头的文件，但包括其它文件和子目录下的单文件  - "js/test*"  # 不包括 'source/js/' 及其子目录中任何以 'test' 开头的文件  - "js/**/test*"  # 不要用 exclude 来忽略 'source/_posts/' 中的文件。你应该使用 'skip_render'，或者在要忽略的文件的文件名之前加一个下划线 '_'  # 在这里配置一个 - "_posts/hello-world.md" 是没有用的。ignore:  # Ignore any folder named 'foo'.  - "**/foo"  # Ignore 'foo' folder in 'themes/' only.  - "**/themes/*/foo"  # Same as above, but applies to every subfolders of 'themes/'.  - "**/themes/**/foo"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>列表中的每一项都必须用单引号或双引号包裹起来。</p><p><code>include</code> 和 <code>exclude</code> 并不适用于 <code>themes/</code> 目录下的文件。如果需要忽略 <code>themes/</code> 目录下的部分文件或文件夹，可以使用 <code>ignore</code> 或在文件名之前添加下划线 <code>_</code>。</p><p><img src="https://i.loli.net/2020/05/02/AfHOY5RXge9tlVo.png" alt="微信公众号"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境搭建 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Hexo】使用Hexo+github pages+travis ci搭建好看的个人博客（一）</title>
      <link href="/legend-blog/2020/05/02/hexo-start/"/>
      <url>/legend-blog/2020/05/02/hexo-start/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/legend-blog/assets/css/APlayer.min.css"><script src="/legend-blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、说明"><a href="#一、说明" class="headerlink" title="一、说明"></a>一、说明</h2><p>本系列文章将会详细说明使用 <code>Hexo</code> + <code>github pages</code> 来搭建个人博客，并对主题进行配置，然后使用 <code>travis ci</code> 来进行自动化部署的全过程。</p><p>搭建一个赏心悦目的博客，写文章和阅读也会更加舒适，一次搭建，终生使用，而且还全程免费，何乐而不为呢。</p><p>通过本系列文章的学习，你将收获一个免费且漂亮的个人博客，并熟悉搭建、写作、部署的全流程以及其中一些很好用的工具。</p><h2 id="二、成品展示"><a href="#二、成品展示" class="headerlink" title="二、成品展示"></a>二、成品展示</h2><p><a target="_blank" rel="noopener" href="https://mfrank2016.github.io/breeze-blog/">在线 Demo</a></p><p><img src="https://i.loli.net/2020/05/02/j6fIGtNmqB9Vlgi.jpg" alt="hexo-1.jpg"><br><img src="https://i.loli.net/2020/05/02/Eko6AGPpxIfrUMX.jpg" alt="hexo-2.jpg"><br><img src="https://i.loli.net/2020/05/02/g8FYkmlAK7dX2qc.jpg" alt="hexo-3.jpg"><br><img src="https://i.loli.net/2020/05/02/pcWruwXdm3aO7VZ.jpg" alt="hexo-4.jpg"><br><img src="https://i.loli.net/2020/05/02/OCNwnEh3SdvBUe4.jpg" alt="hexo-5.jpg"></p><p>这只是其中的一个主题，如果不喜欢，也可以很方便的切换其它主题。</p><p><code>hexo</code> 主题相当丰富，可以在<a target="_blank" rel="noopener" href="https://hexo.io/themes/">这里</a>选择喜欢的主题进行切换即可。</p><h2 id="三、前期准备"><a href="#三、前期准备" class="headerlink" title="三、前期准备"></a>三、前期准备</h2><p>在开始搭建之前，需要准备以下几样东西：</p><ul><li>本地安装 <code>node.js</code></li><li>本地安装 <code>git</code></li><li>一个 <code>github</code> 账号</li><li>创建一个 <code>github</code> 仓库</li><li>一个 <code>travis ci</code> 账号</li></ul><p>已经有过安装经验的同学，可以根据自己情况选择性的跳过部分章节。</p><h3 id="本地安装-node-js"><a href="#本地安装-node-js" class="headerlink" title="本地安装 node.js"></a>本地安装 node.js</h3><p><code>windows</code> 系统可以在<a target="_blank" rel="noopener" href="https://nodejs.org/zh-cn/download/">这里</a>下载 <code>installer</code> 安装包进行安装。</p><p><code>mac</code> 系统可以在<a target="_blank" rel="noopener" href="https://nodejs.org/zh-cn/download/">这里</a>下载 <code>pkg</code> 安装包，也可以使用 <code>homebrew</code> 进行安装：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">brew install node<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后在命令行输入以下命令来验证是否正确安装:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">node -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="本地安装-git"><a href="#本地安装-git" class="headerlink" title="本地安装 git"></a>本地安装 git</h3><p><code>windows</code> 系统可以从<a target="_blank" rel="noopener" href="https://gitforwindows.org/">这里</a>下载安装包后进行安装。</p><p><code>mac</code> 系统可以从<a target="_blank" rel="noopener" href="https://sourceforge.net/projects/git-osx-installer/">这里</a>下载安装包进行安装。</p><p>也可以使用 <code>homebrew</code> 进行安装：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">brew install git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入以下命令来查看是否正确安装好了 <code>git</code> ：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git --version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后设置自己的用户名和邮箱：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git config --global user.name "你的用户名"git config --global user.email "你的公司或个人邮箱"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="github-账号"><a href="#github-账号" class="headerlink" title="github 账号"></a>github 账号</h3><p>首先，需要注册一个 <code>github</code> 账号，<a target="_blank" rel="noopener" href="https://github.com/join?source=header-home">点击这里</a>。</p><p>填写好用户名和密码，验证完成后，便可以将一个 <code>github</code> 账号收入囊中。</p><p>创建好账号之后，我们还需要把我们本地的 <code>SSH Key</code> 添加到 <code>github</code> 中去，这样我们之后才能有权限将本地代码推送到 <code>github</code> 中。</p><p>先本地生成一对 <code>RSA</code> 密钥：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen -t rsa -b 4096 -C "你的邮箱"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后用食指敲击你的回车键三次，记住，要用食指，但别问为什么。</p><p>找到你刚才创建的密钥，<code>windows</code> 用户可以在 <code>C://用户//admin//.ssh</code> 目录下查找，mac 用户可以在 <code>~/.ssh</code> 目录下找到。复制 <code>id_rsa.pub</code> 文件里的信息，然后到<a target="_blank" rel="noopener" href="https://github.com/settings/keys">这里</a>添加新的 <code>SSHKEY</code> 。</p><p><img src="https://i.loli.net/2020/05/02/k3uVFawNbvL84eB.jpg" alt="hexo-10.jpg"></p><p><img src="https://i.loli.net/2020/05/02/ijrXcU1ZT96QqsP.jpg" alt="hexo-11.jpg"></p><p>把我们刚才的 <code>key</code> 复制进行后保存即可。</p><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>点击<a target="_blank" rel="noopener" href="https://github.com/new">这里</a>，创建一个新的仓库。</p><p><img src="https://i.loli.net/2020/05/02/zoDx4HQrACMSYbI.png" alt="hexo-5.jpg"></p><p>仓库名称可以随便取，比如：<code>blog</code>、<code>my-blog</code>，随便取一个就好。仓库说明也可以随便写，可以大概描述一下你这个仓库是做什么的。可以参考一下<a target="_blank" rel="noopener" href="https://github.com/MFrank2016/breeze-blog">我的仓库</a></p><p>然后把仓库地址记下来，是下图中箭头标示的 <code>git</code> 开头的地址，后面需要用到。</p><p><img src="https://i.loli.net/2020/05/02/e36Vp8isyRfYvaw.jpg" alt="hexo-12.jpg"></p><p>创建好仓库之后，就可以进行下一步了。</p><h3 id="travis-ci-账号"><a href="#travis-ci-账号" class="headerlink" title="travis ci 账号"></a>travis ci 账号</h3><p><code>travis ci</code> 账号是跟 <code>github</code> 账号关联的，所以需要先创建好 <code>github</code> 账号，创建好之后，点击<a target="_blank" rel="noopener" href="https://travis-ci.org/signin">这里</a>进行账号关联登陆。</p><p>在设置里进行一次<a target="_blank" rel="noopener" href="https://travis-ci.org/account/repositories">账户同步</a>：</p><p><img src="https://i.loli.net/2020/05/02/Th5tdWvNYlXbz3D.jpg" alt="hexo-7.jpg"></p><p>同步完后刷新一下页面，刚才创建的仓库应该就会出现在这里：</p><p><img src="https://i.loli.net/2020/05/02/vznkDHh9frOMlIX.jpg" alt="hexo-8.jpg"></p><h2 id="四、安装-Hexo"><a href="#四、安装-Hexo" class="headerlink" title="四、安装 Hexo"></a>四、安装 Hexo</h2><p><code>hexo</code> 是一款静态网站生成工具，可以根据设置的主题样式和配置文件，来生成丰富多彩的网页，通常配置文件设置好之后不需要经常修改，我们只需要负责写好我们的博文，写好之后就能使用命令一键生成网站，而且还可以为所欲为的切换主题，可以说是写博客的一大利器。</p><p><code>hexo</code> 的安装其实很简单，只需要输入以下咒语：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install -g hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后轻轻的敲击你的回车键，<code>hexo</code> 便能成功的安装在你的电脑中。</p><p>可以使用以下命令进行验证：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="五、使用-hexo-搭建博客"><a href="#五、使用-hexo-搭建博客" class="headerlink" title="五、使用 hexo 搭建博客"></a>五、使用 hexo 搭建博客</h2><p>选择一个准备放置博客网站的目录，然后使用以下命令来初始化一个项目：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo init breeze-blogcd breeze-blognpm install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>该命令将会在当前目录下，生成一个名为 <code>breeze-blog</code> 的新目录，当然，你可以把这个名字换成任何你想要的名字，并将 <code>hexo</code> 的初始化文件写入其中。</p><p>新建完成后，<code>breeze-blog</code> 文件夹的目录如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.├── _config.yml├── package.json├── node_modules├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>_config.yml</code> 是配置文件，里面有很多可以配置的数据，这里暂时不多介绍，后面的文章里会进行详细说明。</p><p><code>package.json</code> 是应用程序信息，通常不需要关心。</p><p><code>node_modules</code> 用来存放 <code>node</code> 相关的模块，通常不需要关心。</p><p><code>scaffolds</code> 里面是模版文件，也就是每次新建文章时，都会根据模版文件来创建对应的 <code>md</code> 文件，这一点也会在后续的文章里进行详细介绍。</p><p><code>source</code> 是资源文件夹，用来存放用户资源的地方。除 <code>_posts</code> 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。</p><p><code>theme</code> 是主题文件夹，每个主题的配置都会有些不一样，需要根据具体主题情况来定，后续介绍主题的文章里会有说明。</p><p>在 <code>breeze-blog</code> 目录下使用以下命令来运行我们的博客：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在默认情况下，服务会使用 <code>4000</code> 端口，如果已经被占用，也可以添加 <code>-p</code> 参数来换用其它端口：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo server -p 8080<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>打开 <code>http://localhost:4000</code> 即可访问我们生成的网站了。</p><p><img src="https://i.loli.net/2020/05/02/ntX31VrhMTjFozQ.jpg" alt="hexo-9.jpg"></p><p>这样，我们的博客就搭建起来了。</p><h2 id="六、部署到-github-pages"><a href="#六、部署到-github-pages" class="headerlink" title="六、部署到 github pages"></a>六、部署到 github pages</h2><p><code>github pages</code> 可以理解为 <del>gayhub</del> <code>github</code> 提供的免费网页空间，可以用来存放你的静态网页文件，并通过 <code>https://用户名.github.io/项目名/</code> 的方式来访问，比如我新创建的 <code>blog</code> 地址就是：<code>https://mfrank2016.github.io/breeze-blog/</code>。</p><p>利用 <code>github pages</code> 就能创建我们的免费博客站点了，至于为什么要使用免费站点，而不选择购买服务器来搭建，是因为根据之前使用服务器经常忘记续费，导致博客数据丢失，损失惨重。<code>github</code> 已经稳定运行了很多年，是全球最大的 <del>同性交友网站</del> 开发者网站，他们的服务值得信赖。而且是免费的。</p><p>我们之前已经注册好 <code>github</code> 的账号并创建好了对应的仓库，本地也安装好了 <code>git</code> ，现在让我们来把他们利用起来。（如果还没有完成的同学可以往上面翻翻，先完成前面的步骤）</p><blockquote><p>注意：有两种类型的 <code>github pages</code>，一种是使用 <code>用户名.github.io</code> 作为项目名，一种是使用其它名称。虽然看起来只是名字不一样，但两种方式其实是有差异的，前一种方式里，网页静态文件只能存放在 master 分支，所以如果想要把博客源文件也存到同一个仓库，必须使用其它分支来存放，相应的 travis ci 监听和推送的分支也需要修改，当然也可以使用另一个新的仓库来存放。后一种方式则没这个限制，通常使用名为 <code>gh-pages</code> 作为分支名，<code>Hexo</code> 内默认设置的分支也是叫这个名字。这里我们使用的是后一种方案，即源文件和生成的网页静态文件存放在同一个仓库，源文件在 <code>master</code> 分支，静态文件在 <code>gh-pages</code> 分支。</p></blockquote><p>首先，我们将本地的文件推送到 <code>github</code> 上。</p><p>在 <code>breeze-blog</code> 目录下，初始化 <code>git</code> 仓库，将现有文件添加到 <code>git</code> 仓库中，并创建 <code>gh-pages</code> 分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd breeze-bloggit initgit add .git commit -am"init blog"git remote add origin 仓库地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>仓库地址是前面我们创建仓库时说过的地址，比如我的地址是： <code>git@github.com:MFrank2016/breeze-blog.git</code> ，把它复制到这里来替换即可。</p><p>然后我们使用最后一句咒语，把代码推送到仓库中去。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git push -u origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果你的仓库原来已经有数据了，可以添加 -f 参数来强制推送，但这样会使得你原来的数据丢失，所以慎用。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git push -f -u origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后创建一个新的本地分支 <code>gh-pages</code>，并关联远程分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git checkout -b gh-pagesgit push -u origin gh-pages<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>⚠️不要改用其它分支名。</p><p>然后在项目 <code>settings</code> 页面里开启 <code>github pages</code>：</p><p><img src="https://i.loli.net/2020/05/02/bQWKGwMsAVYk5hp.jpg" alt="hexo-13.jpg"></p><p><img src="https://i.loli.net/2020/05/02/HqpxGos7J9mLRkC.jpg" alt="hexo-14.jpg"></p><p>这里要选择 <code>gh-pages</code> 分支，不要选 <code>master</code> 分支。</p><p>然后我们修改一下 <code>hexo</code> 的配置文件(<code>_config.yml</code>)，找到对应的地方进行修改，指定我们的仓库信息，并修改 <code>root</code> 和 <code>url</code> 信息。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">url: https://mfrank2016.github.io/root: /breeze-blog/deploy:  type: 'git'  repo: git@github.com:MFrank2016/breeze-blog  branch: gh-pages<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把这里的 <code>repo</code> 地址修改为你的仓库地址即可。</p><p>安装 <code>hexo-deployer-git</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd breeze-blognpm install hexo-deployer-git --save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>万事具备，发车！</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo clean &amp;&amp; hexo generatehexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>运行完成后，我们的博客文件就顺利部署到 <code>github pages</code> 上了，现在我们打开下面网址来查看我们的博客效果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">https://用户名.github.io/项目名/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后每次我们添加或修改完本地文件后，使用：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo clean &amp;&amp; hexo g -d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>即可重新生成项目文件，并推送到 <code>github</code> 项目的 <code>gh-pages</code> 分支，为了备份数据，也方便我们在不同设备上进行编辑，最好将我们修改的文件推送到 <code>master</code> 分支进行保存：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git checkout mastergit add .git commit -am "这里可以写一下修改的备注信息"git push<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="七、使用-travis-ci-进行自动化部署"><a href="#七、使用-travis-ci-进行自动化部署" class="headerlink" title="七、使用 travis ci 进行自动化部署"></a>七、使用 travis ci 进行自动化部署</h2><p>如果我们每次都按前面的方式进行操作，也会略显麻烦，使用 <code>travis ci</code> 后，可以将前面部署的步骤自动化，我们只需要将本地修改的文件推送到 <code>github</code> 仓库，就会触发 <code>travis ci</code> 的自动部署。</p><p><code>travis ci</code> 的配置也很简单，而且只需要配置一次，之后就不需要修改了。</p><p>首先，我们需要把*_config.yml<em>文件里的</em>repo*信息注释一下，不需要在配置文件里指定仓库地址，<code>travis ci</code> 会直接在其监听项目上进行部署。</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">deploy:  type: 'git'#  repo: git@github.com:MFrank2016/breeze-blog  branch: gh-pages<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在本地博客目录下创建一个名为 <code>.travis.yml</code> 的文件，与 <code>_config.yml</code> 要在同级目录。</p><p>然后在文件中写入以下内容：</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">sudo: falselanguage: node_jsnode_js:  - 12cache: npmbranches:  only:    - master # build master branch onlyscript:  - hexo generatedeploy:  provider: pages  skip-cleanup: true  github-token: $GH_TOKEN  keep-history: true  on:    branch: master  local-dir: public<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里没有任何东西需要修改，直接复制粘贴即可。</p><p>接下来，需要在 <code>travis</code> 里配置一个环境变量，<code>GH_TOKEN</code> 。</p><p>前面我们已经将 <code>travis</code> 关联了 <code>github</code> 账号，并同步了项目，如果操作正确，<a target="_blank" rel="noopener" href="https://travis-ci.org/dashboard">这里</a>应该会出现我们的仓库信息。</p><p><img src="https://i.loli.net/2020/05/02/Xc2OGJvDNFbhYPs.jpg" alt="hexo-15.jpg"></p><p><img src="https://i.loli.net/2020/05/02/E7QyHTNMdjJWP26.jpg" alt="hexo-16.jpg"></p><p><img src="https://i.loli.net/2020/05/02/qjJkhAgErKL5tUR.jpg" alt="hexo-17.jpg"></p><p>这里的 <code>access token</code> 是指 <code>github token</code>，可以在<a target="_blank" rel="noopener" href="https://github.com/settings/tokens">这里</a>获取：</p><p><img src="https://i.loli.net/2020/05/02/K35fhMCGLJ7xiUw.jpg" alt="hexo-18.jpg"></p><p><img src="https://i.loli.net/2020/05/02/7wNrX19YqGZKLOs.jpg" alt="hexo-19.jpg"></p><p>选好后，点击 <code>generate</code> 即可生成一个新的 <code>access token</code>，这个 <code>token</code> 即是用于权限验证的，好好保存，不要泄露，千万不要直接写到 <code>config</code> 文件里，而且之后是无法进行查看的，所以需要记录在一个安全的地方。</p><p>创建好之后，把这个 <code>token</code> 填写到前面的 <code>travis ci</code> 的项目环境变量中保存，这样一切就准备好了。</p><p>现在让我们在本地创建一篇新的博客，然后推送到远程仓库：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd breeze-bloggit checkout masterhexo new "my first blog"git add .git commit -am"add a new blog"git push<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我们可以在 <code>travis ci</code> 中看到构建过程被触发了，等待一会即可完成部署，然后再打开我们的博客，查看一下我们新生成的文章是否已经在上面了。（浏览器有缓存，所以可能需要刷新几次才有效果）</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>整个过程看起来有些麻烦，距上次部署博客已经有很长时间了，我也是摸索了几次后才大致掌握，因为不想每次都重新来一遍，所以还是记录一下为好，利人利己。</p><p>写博客是一种生活态度，记录并整理生活和编程中的心得和经验并分享，在漫漫人生路上留下自己一路走来的印记，这样以后再回过头来看时，就不会感慨时间都去哪了。如果能因此遇到有共同兴趣爱好的人，那也将会是人生里的不错点缀。</p><p>这里只是完成了博客搭建和自动化部署的过程，关于博客的配置和主题的配置以及博客写作的一些技巧会在后面的文章中进行说明，敬请关注～</p><p><img src="https://i.loli.net/2020/05/02/AfHOY5RXge9tlVo.png" alt="微信公众号"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境搭建 </tag>
            
            <tag> Hexo </tag>
            
            <tag> github pages </tag>
            
            <tag> travis ci </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给jekyll添加炫酷简洁的搜索</title>
      <link href="/legend-blog/2019/02/24/2019-02-24-%E7%BB%99jekyll%E6%B7%BB%E5%8A%A0%E7%82%AB%E9%85%B7%E7%AE%80%E6%B4%81%E7%9A%84%E6%90%9C%E7%B4%A2/"/>
      <url>/legend-blog/2019/02/24/2019-02-24-%E7%BB%99jekyll%E6%B7%BB%E5%8A%A0%E7%82%AB%E9%85%B7%E7%AE%80%E6%B4%81%E7%9A%84%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/legend-blog/assets/css/APlayer.min.css"><script src="/legend-blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ol><li>点击右下角图标进行搜索</li><li>双击ctrl键进行搜索或关闭</li><li>搜索页面点击右上角关闭按钮关闭搜索试图</li></ol><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p>将search目录放至于博客根目录下，其中search目录结构如下:</p><pre class="line-numbers language-none"><code class="language-none">search ├── cb-footer-add.html ├── cb-search.json ├── css │&nbsp;&nbsp; └── cb-search.css ├── img │&nbsp;&nbsp; ├── cb-close.png │&nbsp;&nbsp; └── cb-search.png └── js     ├── bootstrap3-typeahead.min.js     └── cb-search.js<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在 <code>_include/footer.html</code> 中的 <code>&lt;/footer&gt;</code> <strong>后</strong>加入 <code>cb-footer-add.html</code> 中的内容即可</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown基本语法</title>
      <link href="/legend-blog/2019/01/22/2019-01-22-markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/legend-blog/2019/01/22/2019-01-22-markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/legend-blog/assets/css/APlayer.min.css"><script src="/legend-blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h2><p>总共六级标题，在#后面要有一个空格</p><pre class="line-numbers language-none"><code class="language-none"># 1级标题## 2级标题### 3级标题#### 4级标题##### 5级标题###### 6级标题<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><h3 id="1级标题"><a href="#1级标题" class="headerlink" title="1级标题"></a>1级标题</h3></li><li><h3 id="2级标题"><a href="#2级标题" class="headerlink" title="2级标题"></a>2级标题</h3></li><li><h3 id="3级标题"><a href="#3级标题" class="headerlink" title="3级标题"></a>3级标题</h3></li><li><h3 id="4级标题"><a href="#4级标题" class="headerlink" title="4级标题"></a>4级标题</h3></li><li><h3 id="5级标题"><a href="#5级标题" class="headerlink" title="5级标题"></a>5级标题</h3></li><li><h3 id="6级标题"><a href="#6级标题" class="headerlink" title="6级标题"></a>6级标题</h3></li></ul><h2 id="二、列表"><a href="#二、列表" class="headerlink" title="二、列表"></a>二、列表</h2><p>无序列表每一行前面加上*或-，符号与文字之间要加一个空格</p><pre class="line-numbers language-none"><code class="language-none">* 1* 2* 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>1</li><li>2</li><li>3</li></ul><pre class="line-numbers language-none"><code class="language-none">- 1- 2- 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>1</p></li><li><p>2</p><p>有序列表行第一行加上1.，第二行加上2.，依次类推，然后每个字符与文字间也要加上空格</p></li></ul><pre class="line-numbers language-none"><code class="language-none">1. 12. 23. 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li>1</li><li>2</li><li>3</li></ol><h2 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h2><pre class="line-numbers language-none"><code class="language-none">&gt; 引用<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>引用</p></blockquote><p><strong>引用嵌套</strong></p><pre class="line-numbers language-none"><code class="language-none">&gt; 第一层引用&gt;&gt; 第二层引用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>第一层引用</p><blockquote><p>第二层引用</p></blockquote></blockquote><blockquote><p><a href=""></a>  前面是说明, 后面是链接</p></blockquote><h2 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h2><pre class="line-numbers language-是" data-language="是"><code class="language-是">---<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="五、粗体与斜体"><a href="#五、粗体与斜体" class="headerlink" title="五、粗体与斜体"></a>五、粗体与斜体</h2><pre class="line-numbers language-none"><code class="language-none">**粗体**<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>粗体</strong></p><pre class="line-numbers language-none"><code class="language-none">*斜体*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><em>斜体</em></p><pre class="line-numbers language-none"><code class="language-none">***即是粗体也是斜体***<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><em><strong>即是粗体也是斜体</strong></em></p><h2 id="六、代码框"><a href="#六、代码框" class="headerlink" title="六、代码框"></a>六、代码框</h2><pre class="line-numbers language-none"><code class="language-none">`hello my friend`<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>hello my friend</code></p><pre class="line-numbers language-none"><code class="language-none">`hello my friend   me too`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>  <code>hello my friend    me too</code></p><h2 id="七、表格"><a href="#七、表格" class="headerlink" title="七、表格"></a>七、表格</h2><ul><li>简单方式</li></ul><pre class="line-numbers language-none"><code class="language-none">Name | Academy | score - | :-: | -: Harry Potter | Gryffindor| 90 Hermione Granger | Gryffindor | 100 Draco Malfoy | Slytherin | 90<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>Name</th><th align="center">Academy</th><th align="right">score</th></tr></thead><tbody><tr><td>Harry Potter</td><td align="center">Gryffindor</td><td align="right">90</td></tr><tr><td>Hermione Granger</td><td align="center">Gryffindor</td><td align="right">100</td></tr><tr><td>Draco Malfoy</td><td align="center">Slytherin</td><td align="right">90</td></tr></tbody></table><ul><li>原生方式</li></ul><pre class="line-numbers language-none"><code class="language-none">| Name | Academy | score | | - | :-: | -: | | Harry Potter | Gryffindor| 90 | | Hermione Granger | Gryffindor | 100 | | Draco Malfoy | Slytherin | 90 |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>Name</th><th align="center">Academy</th><th align="right">score</th></tr></thead><tbody><tr><td>Harry Potter</td><td align="center">Gryffindor</td><td align="right">90</td></tr><tr><td>Hermione Granger</td><td align="center">Gryffindor</td><td align="right">100</td></tr><tr><td>Draco Malfoy</td><td align="center">Slytherin</td><td align="right">90</td></tr></tbody></table><hr><h2 id="八、插入图片"><a href="#八、插入图片" class="headerlink" title="八、插入图片"></a>八、插入图片</h2><p>插入图片有插入本地图片和插入图片外链两种方式</p><p>这里我推荐使用图片外链方式：将图片上传到图床，然后生成markdown外链粘贴过来即可，本地图片已丢失，且博客加载速度慢，有一说是将图片转为base64也可以，没具体试</p><p><strong>方法一</strong>(<strong>不推荐</strong>)：我用的win10，mac推荐的图床是ipic，但是ipic没有出windows版的，经过好久的收集，发现一种图床(亲测有效！)附上百度云链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1_20X7lApQU-4R1M6Jx7Xfg">mpic</a> ,提取码：czc7</p><p>不过要用mpic还需要注册<a target="_blank" rel="noopener" href="https://portal.qiniu.com/signup">七牛云</a>获取对象存储空间，注册登陆后，添加对象存储</p><p><a target="_blank" rel="noopener" href="https://i.loli.net/2019/02/23/5c716451ddec0.png"><img src="https://i.loli.net/2019/02/23/5c716451ddec0.png" alt="2019-02-23_231802.png"></a></p><p><a target="_blank" rel="noopener" href="https://i.loli.net/2019/02/23/5c7164d4d0fd6.png"><img src="https://i.loli.net/2019/02/23/5c7164d4d0fd6.png" alt="2019-02-23_231945.png"></a></p><p>进入密钥管理</p><p><a target="_blank" rel="noopener" href="https://i.loli.net/2019/02/23/5c71651fd7ab6.png"><img src="https://i.loli.net/2019/02/23/5c71651fd7ab6.png" alt="2019-02-23_232139.png"></a></p><p>然后将对应的七牛空间名，AK，SK输入登陆mpic账号，在想插入图片时，直接将图片拖到mpic界面，可上传到图床，然后返回一个markdown外链，复制粘贴即可</p><p><strong>but</strong>，我不推荐大家用七牛云，因为，测试域名只有30天，时间过了，你插入的图片外链都挂了，这样博主的悲剧就会再次发生(hate死七牛云了，得截图一个一个换…)，如果你有时间，备案下域名，就可以很方便使用七牛云，楼主买的阿里域名，美其名曰域名备份，你还学要买服务器，所以博主果断放弃了</p><p><strong>方法二</strong>：推荐大家使用 <a target="_blank" rel="noopener" href="https://sm.ms/">sm.ms</a></p><ul><li>使用SM.MS官方API，图床稳定，支持 <strong>HTTPS</strong>。</li><li>支持多文件同时上传（每次最多选择十个图片，且每个图片大小不超过5M）</li><li>支持常见的图片格式  (.png|.jpg|.gif|.webp|.jpeg)</li></ul><h2 id="九、高亮"><a href="#九、高亮" class="headerlink" title="九、高亮"></a>九、高亮</h2><p>如下图实现高亮</p><p><a target="_blank" rel="noopener" href="https://i.loli.net/2019/02/24/5c72a1bf44f7c.png"><img src="https://i.loli.net/2019/02/24/5c72a1bf44f7c.png" alt="2019-02-24_215115.png"></a></p><p>例如：</p><pre class="line-numbers language-none"><code class="language-none">```你的内容```<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>你的内容</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用github Pages和jekyll创建个人博客</title>
      <link href="/legend-blog/2019/01/21/2019-01-21-%E5%88%A9%E7%94%A8Github-Pages%E5%92%8Cjekyll%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/legend-blog/2019/01/21/2019-01-21-%E5%88%A9%E7%94%A8Github-Pages%E5%92%8Cjekyll%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/legend-blog/assets/css/APlayer.min.css"><script src="/legend-blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>不积跬步，无以至千里</p><p>不积小流，无以成江海 </p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><hr><p>博主今年大三，现就读于西安一所211高校，是一个对未来迷茫的考验党。</p><p>之前也折腾过一个博客，那时是用wordpress搭建的，还花了钱买了服务器（腾讯云学生价120/年），但是一直没动手写文章，因为觉得麻烦，不如去学点新东西，新技术（比如近些年来的，机器学习深度学习之类的），古人说的好：<strong>术业有专攻</strong>，盲目追求技术的后果就是<strong>什么都会一点，什么都不会</strong>，于是索性就想着再弄一个<strong>不花钱</strong>的博客，来记录自己的学习历程和心得，毕竟没有过目不忘的脑子，只能靠多巩固来弥补技术间隙性的遗忘。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><hr><p><em>本篇文章采用Github Pages+jekyll快速搭建个人博客</em></p><h3 id="1-注册-登录你的github"><a href="#1-注册-登录你的github" class="headerlink" title="1.注册+登录你的github"></a>1.注册+登录你的github</h3><p>首先，你得拥有一个github账号，如果没有，赶紧去注册一个吧!  <a target="_blank" rel="noopener" href="http://github.com/">Github</a></p><p><a target="_blank" rel="noopener" href="https://imgchr.com/i/kPtvJ1"><img src="https://s2.ax1x.com/2019/01/21/kPtvJ1.md.png" alt="kPtvJ1.md.png"></a></p><p>​      <strong>sign up</strong> 注册一个账号</p><p>​      <strong>sign in</strong>  登录你的账号</p><h3 id="2-Fork-拉取-我的博客模板"><a href="#2-Fork-拉取-我的博客模板" class="headerlink" title="2.Fork(拉取)我的博客模板"></a>2.Fork(拉取)我的博客模板</h3><p>登录github账号后，进入<a target="_blank" rel="noopener" href="https://github.com/cfhyxxj/cfhyxxj.github.io/">我的仓库</a>中,点击Fork，就可拉取到我的博客模板到自己的仓库中</p><p><a target="_blank" rel="noopener" href="https://imgchr.com/i/kPNsYR"><img src="https://s2.ax1x.com/2019/01/21/kPNsYR.md.png" alt="kPNsYR.md.png"></a></p><h3 id="3-修改repository-仓库-名"><a href="#3-修改repository-仓库-名" class="headerlink" title="3.修改repository(仓库)名"></a>3.修改repository(仓库)名</h3><p>在第2步的基础上，点击setting</p><p><a target="_blank" rel="noopener" href="https://imgchr.com/i/kPNTfI"><img src="https://s2.ax1x.com/2019/01/21/kPNTfI.md.png" alt="kPNTfI.md.png"></a></p><p>修改repository name 为:         你的github名.github.io </p><p>例如我的github账号是：cfhyxxj，则我的这个repository name 应改为： cfhyxxj.github.io</p><p>接着点击Rename即可</p><p><a target="_blank" rel="noopener" href="https://imgchr.com/i/kPUCpq"><img src="https://s2.ax1x.com/2019/01/21/kPUCpq.md.png" alt="kPUCpq.md.png"></a></p><h3 id="4-检查上述步骤是否成功"><a href="#4-检查上述步骤是否成功" class="headerlink" title="4.检查上述步骤是否成功"></a>4.检查上述步骤是否成功</h3><p>在浏览器上输入网址：你的github名.github.io</p><p>会出现如下图所示的博客界面，不过还得修改下，才能改成你自己的博客</p><p><a target="_blank" rel="noopener" href="https://i.loli.net/2019/02/24/5c72087af0345.png"><img src="https://i.loli.net/2019/02/24/5c72087af0345.png" alt="2019-02-24_105839.png"></a></p><h2 id="整个网站的架构"><a href="#整个网站的架构" class="headerlink" title="整个网站的架构"></a>整个网站的架构</h2><pre class="line-numbers language-none"><code class="language-none">├── _config.yml├── _drafts|   ├── begin-with-the-crazy-ideas.textile|   └── on-simplicity-in-technology.markdown├── _includes|   ├── footer.html|   └── header.html├── _layouts|   ├── default.html|   └── post.html├── _posts|   ├── 2007-10-29-why-every-programmer-should-play-nethack.textile|   └── 2009-04-26-barcamp-boston-4-roundup.textile├── _data|   └── members.yml├── _site├── img└── index.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中重要的就是这几个文件：</p><ul><li>_config.yml   全局配置文件</li><li>_posts 存放博客文章的文件夹</li><li>img  存放个人博客网站上少量的图片(博客文章里插入的是图片外链，图片放置在图床，加快了博客加载速度，后面还会提到)</li><li>想自己设计界面，可以看这里<a target="_blank" rel="noopener" href="https://www.jekyll.com.cn/docs/structure/">jekyll文档</a></li></ul><h2 id="修改全局配置"><a href="#修改全局配置" class="headerlink" title="修改全局配置"></a>修改全局配置</h2><p>在你的仓库里，找到_config.yml文件，双击打开</p><p>然后对此文件进行修改(可对照下面设置和网站页面改)</p><p><a target="_blank" rel="noopener" href="https://imgchr.com/i/kP2hF0"><img src="https://s2.ax1x.com/2019/01/21/kP2hF0.md.png" alt="kP2hF0.md.png"></a></p><h3 id="网站设置"><a href="#网站设置" class="headerlink" title="网站设置"></a>网站设置</h3><pre class="line-numbers language-none"><code class="language-none"># Site settingstitle: charryglomc   #这个标题会显示在左上角(返回主页)和header图片中间字体SEOTitle: 春风化雨的博客  #这个标题显示在浏览器标签页上header-img: img/post-bg-desk.jpg  #主页上部图片email: 798577670@qq.com  description: ""keyword: "春风化雨的博客, cfhyxxj"url: "http://cfhyxxj.github.io"          # your host, for absolute URLbaseurl: ""      # for example, '/blog' if your blog hosted on 'host/blog'github_repo: "https://github.com/cfhyxxj/cfhyxxj.github.io.git" # you code repository<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="侧边栏"><a href="#侧边栏" class="headerlink" title="侧边栏"></a>侧边栏</h3><pre class="line-numbers language-none"><code class="language-none"># Sidebar settingssidebar: true                           # true为有侧边栏sidebar-about-description: "花开堪折直须折,莫待无花空折枝"  #侧边栏描述sidebar-avatar: /img/zz.png      #本领想用二柱子头像的，但是觉得并不合适<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="修改个人介绍"><a href="#修改个人介绍" class="headerlink" title="修改个人介绍"></a>修改个人介绍</h3><p>在about.html文件里，可对照着改</p><h3 id="社交账号"><a href="#社交账号" class="headerlink" title="社交账号"></a>社交账号</h3><p><img src="http://upload-images.jianshu.io/upload_images/2178672-ec775a22f76e2f40.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><pre class="line-numbers language-none"><code class="language-none"># SNS settingsRSS: false# weibo_username:     #zhihu_username:     github_username:    cfhyxxj   #不填就注释掉，博主只想要star，hhh#facebook_username:  #jianshu_username:   #twitter_username:  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h3><p>我推荐用<strong>gitalk</strong>评论插件，<strong>gitalk</strong>是由github账号登录，接下来改一下下面的参数就好了</p><pre class="line-numbers language-none"><code class="language-none"># Gitalkgitalk:  enable: true    #是否开启Gitalk评论  clientID:  xxxxxxxxxxxxxxx                  #生成的clientID  clientSecret:  xxxxxxxxxxxxxx              #生成的clientSecret  repo: cfhyxxj.github.io    #改为自己的仓库名称  owner: cfhyxxj    #改为自己的github用户名  admin: cfhyxxj    #同上  distractionFreeMode: true #是否启用类似FB的阴影遮罩<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="获取clientID和clientSecret"><a href="#获取clientID和clientSecret" class="headerlink" title="获取clientID和clientSecret"></a>获取clientID和clientSecret</h4><p>首先申请一个<a target="_blank" rel="noopener" href="https://github.com/settings/applications/new">Github Application</a>，如下照着改为自己的就行了</p><p><img src="https://s2.ax1x.com/2019/01/21/kPWM8K.png" alt="kPWM8K.png"></p><p>登录后，往下滑，就可看到自己的<strong>clientID</strong>和<strong>clientSecret</strong></p><h3 id="网站统计"><a href="#网站统计" class="headerlink" title="网站统计"></a>网站统计</h3><p>集成了 <a target="_blank" rel="noopener" href="http://tongji.baidu.com/web/welcome/login">Baidu Analytics</a> 和 <a target="_blank" rel="noopener" href="http://www.google.cn/analytics/">Google Analytics</a>，到各个网站注册拿到<strong>track_id</strong>替换下面的就可以了</p><pre class="line-numbers language-none"><code class="language-none"># Analytics settings# Baidu Analyticsba_track_id: xxxxxxxxxxxxxxxxxxxxxxxx# Google Analyticsga_track_id: 'xxxxxxxxx'            # Format: UA-xxxxxx-xxga_domain: auto<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="好友"><a href="#好友" class="headerlink" title="好友"></a>好友</h3><pre class="line-numbers language-none"><code class="language-none">friends: [    {        title: "简书·BY",        href: "http://www.jianshu.com/u/e71990ada2fd"    },{        title: "Apple",        href: "https://apple.com"    },{        title: "Apple Developer",        href: "https://developer.apple.com/"    }]     #如不想用可用#注释掉，但要一行一行注释<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><pre class="line-numbers language-none"><code class="language-none"># Featured Tagsfeatured-tags: true                     # 是否使用首页标签featured-condition-size: 0              # 相同标签数量大于这个数，才会出现在首页<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="提交保存"><a href="#提交保存" class="headerlink" title="提交保存"></a>提交保存</h3><p>将网页拉到底部，提交所有的修改</p><p><a target="_blank" rel="noopener" href="https://imgchr.com/i/kPWXRK"><img src="https://s2.ax1x.com/2019/01/21/kPWXRK.md.png" alt="kPWXRK.md.png"></a></p><h3 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h3><p>很幸运还是学生，买域名有优惠，跑题了，hhh</p><p>我买的阿里的域名.top，一年9RMB，是不是觉得特别便宜呢？</p><p>可用淘宝或支付宝登录，然后搜索栏搜索<strong>域名</strong>，输入你想设定的域名，看有没有，然后购买</p><p>买了之后要进行<em><strong>域名解析</strong></em></p><h3 id="ping-ip"><a href="#ping-ip" class="headerlink" title="ping  ip"></a>ping  ip</h3><p>在这之前要在cmd命令行里ping一下 你的github账号.github.io的ip地址</p><p>例如我的：</p><p>ping  cfhyxxj.github.io  </p><p>(可能有不同，最好自己ping一下，这个ip地址应该是最新美国Github Pages服务器的地址)</p><p><a target="_blank" rel="noopener" href="https://imgchr.com/i/kPfKds"><img src="https://s2.ax1x.com/2019/01/21/kPfKds.md.png" alt="kPfKds.md.png"></a></p><h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><p>进入阿里云控制台，双击域名，进入域名控制台，双击解析</p><p><a target="_blank" rel="noopener" href="https://imgchr.com/i/kPfUeJ"><img src="https://s2.ax1x.com/2019/01/21/kPfUeJ.md.png" alt="kPfUeJ.md.png"></a></p><p>添加两条记录解析</p><p>记录类型两条都为A</p><p>主机记录一个为@，一个为www</p><p>记录值为刚才ping的ip地址</p><p><img src="https://i.loli.net/2019/02/23/5c7135bd5b4c1.png" alt="2019-02-23_175417.png"></p><p><img src="https://i.loli.net/2019/02/23/5c71376fa2c06.png" alt="2019-02-23_200609.png"></p><h3 id="修改CNAME"><a href="#修改CNAME" class="headerlink" title="修改CNAME"></a>修改CNAME</h3><p>修改仓库下的CNAME文件内容，改为自己刚注册的域名</p><p><img src="https://i.loli.net/2019/02/23/5c7138f3eff8d.png" alt="2019-02-23_201306.png"></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在浏览器输入域名，直接成功跳转到自己的博客，大功告成！</p><h3 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h3><p>要写文章首先要学习一下<strong>markdown语法</strong>，可以看下<a target="_blank" rel="noopener" href="http://cfhyxxj.top/2019/01/22/markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">markdown基本语法</a></p><p>另外安利一个mardown神器：typora，界面简洁，写下即可渲染。 <a target="_blank" rel="noopener" href="https://www.typora.io/#windows">typora下载链接</a></p><p>博客文章最后是以.md文件的形式保存，.md标题是由下图框框内的yaml自动决定的，也就是你写博客前面要照着如下写</p><p>title，subtitle，date，author，header-img，tags全部由自己设定，最后传文章显示到博客上</p><p><img src="https://i.loli.net/2019/02/23/5c7139b8799c2.png" alt="2019-02-23_201612.png"></p><h3 id="传文章"><a href="#传文章" class="headerlink" title="传文章"></a>传文章</h3><p>将文章上传到自己的博客，可以下载<a target="_blank" rel="noopener" href="https://desktop.github.com/">github-desktop</a>,也可以通过git命令的方式传，</p><p>这里我采用github-desktop传文章</p><h4 id="1-将仓库中的项目下载到本地-Clone-Github-Project-to-Local-Repository"><a href="#1-将仓库中的项目下载到本地-Clone-Github-Project-to-Local-Repository" class="headerlink" title="1.将仓库中的项目下载到本地 (Clone Github Project to Local Repository)"></a>1.将仓库中的项目下载到本地 (Clone Github Project to Local Repository)</h4><p>​首先，你不想每次进入github网站对你的项目文件编辑修改，你可以把它们下载到你的本地磁盘上，然后对项目文件的每一次修改都会被记录下来，可以通过github-desktop同步修改到你的远程仓库上(即本地修改同步到远程仓库)</p><p>点击加号</p><p><img src="https://i.loli.net/2019/02/23/5c713a781c23b.png" alt="2019-02-23_201612.png"></p><p>​选择clone，你可以看到你在github上存放的（尚未下载到本地的）项目列表。选中一个想要下载到本地的项目，选择clone Repository，然后选择本地路径以存放项目文件夹。</p><p>项目文件夹可以随意更换位置，不信你可以试试，hhh</p><p><img src="https://i.loli.net/2019/02/23/5c713ac605a36.png" alt="2019-02-23_202110.png"></p><h4 id="2-在本地仓库更新网页端的改变-（pull"><a href="#2-在本地仓库更新网页端的改变-（pull" class="headerlink" title="2.在本地仓库更新网页端的改变 （pull)"></a>2.在本地仓库更新网页端的改变 （pull)</h4><p>​假如你是和你的合作者一起完成一个项目，他又新提交了一个新文件改变到该项目，你很感兴趣，想要同步到本地，你可以这样做：在网站上点击【Repository】-【Pull】，接着，你就可以看到本地仓库里出现了合作者提交的新文件。</p><h4 id="3-在本地提交新的代码版本到仓库-push-local-changes-to-remote-repository"><a href="#3-在本地提交新的代码版本到仓库-push-local-changes-to-remote-repository" class="headerlink" title="3. 在本地提交新的代码版本到仓库 (push local changes to remote repository)"></a>3. 在本地提交新的代码版本到仓库 (push local changes to remote repository)</h4><p>   修改本地仓库文件后，打开github-desktop，点击changes，有时候可能没有(博主第一次就是这样，一直试了好多次)，那就切换github-desktop界面，直到它出现changes</p><p>   然后填下(Summary)标题和注释(Description)就提交(Commit)</p><p>   <img src="https://i.loli.net/2019/02/23/5c713bd8f0201.png" alt="2019-02-23_202533.png"></p><p>commit后，你会发现你的项目历史结点上多了一个新的环，代表你的上一次commit记录,如下图</p><p><img src="https://i.loli.net/2019/02/23/5c713c3e5b70e.png" alt="2019-02-23_202632.png"></p><p>你可以提交一次，然后点击Sync同步到你的远程仓库，也可以提交多次后迭代，再同步</p><p>同步后，前面的环消失了</p><p><img src="https://i.loli.net/2019/02/23/5c713cd06ff7c.png" alt="2019-02-23_202948.png"></p><h4 id="4-创建新的分支-creating-new-branch"><a href="#4-创建新的分支-creating-new-branch" class="headerlink" title="4. 创建新的分支 (creating new branch)"></a>4. 创建新的分支 (creating new branch)</h4><p>比如，你和朋友一起翻译一本书，你负责翻译成英文，你朋友负责翻译成日文，那么你们也可以分别在两个分支上操作，但这两个分支都属于这本书的翻译项目</p><p>简而言之，所有分支同属一个项目，但每个分支可以互相独立，互不干扰，而有需要时，任意两个分支也可以合并。</p><p>创建新的分支</p><p><a target="_blank" rel="noopener" href="https://i.loli.net/2019/02/23/5c716096acdb6.png"><img src="https://i.loli.net/2019/02/23/5c716096acdb6.png" alt="2019-02-23_230213.png"></a></p><p>​      新的分支publish到远程仓库</p><p><a target="_blank" rel="noopener" href="https://i.loli.net/2019/02/23/5c7160e5aad7e.png"><img src="https://i.loli.net/2019/02/23/5c7160e5aad7e.png" alt="2019-02-23_230345.png"></a></p><p>pull request</p><p><a target="_blank" rel="noopener" href="https://i.loli.net/2019/02/23/5c716120b716d.png"><img src="https://i.loli.net/2019/02/23/5c716120b716d.png" alt="2019-02-23_230345.png"></a></p><p><strong>为什么要pull request？</strong></p><p>很多情况下，很多人是fork(拉取)别人的项目，然后自己进行改进，但是你对别人的项目是没有改动权力的，但是如果你觉得自己的改进非常棒，想贡献自己的代码并成为原项目的contributor之一，于是你就需要发起一个pull request，通过审核，请求原项目的负责人将你的代码合并的原项目中</p><h2 id="jekyll博客本地调试"><a href="#jekyll博客本地调试" class="headerlink" title="jekyll博客本地调试"></a>jekyll博客本地调试</h2><p>github远程提交有延迟，不适合博客进行调试，所以我们需要用到jekyll本地调试</p><p>第一次安装有三个步骤</p><h4 id="1-安装Ruby"><a href="#1-安装Ruby" class="headerlink" title="1. 安装Ruby"></a>1. 安装Ruby</h4><p>进入<a target="_blank" rel="noopener" href="http://rubyinstaller.org/downloads/">Ruby下载链接</a>，根据自己的机型下载对应版本</p><p>博主第一次下载的是最新的，没成功，翻墙下载卡到一半不动了，所以还是果断下了以前的版本</p><p><a target="_blank" rel="noopener" href="https://i.loli.net/2019/02/23/5c7161acd0629.png"><img src="https://i.loli.net/2019/02/23/5c7161acd0629.png" alt="2019-02-23_230647.png"></a></p><p>安装过程中，这两个勾上(默认是没有勾上)</p><p><a target="_blank" rel="noopener" href="https://i.loli.net/2019/02/23/5c7161e97052f.png"><img src="https://i.loli.net/2019/02/23/5c7161e97052f.png" alt="2019-02-23_230810.png"></a></p><p>安装完后测试是否安装成功，命令行输入：ruby -v</p><p><img src="http://plnzlwv2k.bkt.clouddn.com/blog/20190127/fYCK79AmlXcc.png?imageslim" alt="mark"></p><h4 id="2-DevKit下载"><a href="#2-DevKit下载" class="headerlink" title="2. DevKit下载"></a>2. DevKit下载</h4><p>还是在那个<a target="_blank" rel="noopener" href="http://rubyinstaller.org/downloads/">网站</a>,拉到下面，下载DevKit</p><p><a target="_blank" rel="noopener" href="https://i.loli.net/2019/02/23/5c7162267e50e.png"><img src="https://i.loli.net/2019/02/23/5c7162267e50e.png" alt="2019-02-23_230904.png"></a></p><p>在你保存DevKit的文件夹里打开命令行</p><p>例如我保存在D:/DevKit,我先进入这个文件夹，然后按住shift，点击鼠标右键即可打开命令行</p><p>然后输入ruby dk.rb init，自动在文件夹中生成config.yml文件</p><p>用记事本打开这个文件，在文件末尾行添加Ruby文件夹地址，例如我的是C:/Ruby23-x64,然后保存退出</p><h4 id="3-安装jekyll"><a href="#3-安装jekyll" class="headerlink" title="3. 安装jekyll"></a>3. 安装jekyll</h4><p>   ​以下命令都是在命令行里输入</p><p>   ​gem是ruby自带的</p><p>   ​先测试gem是否安装完毕：gem -v</p><pre><code>   [![2019-02-23_230904.png](https://i.loli.net/2019/02/23/5c716251bb26f.png)](https://i.loli.net/2019/02/23/5c716251bb26f.png)</code></pre><p>   然后利用gem安装jekyll：gem install jekyll</p><p>   测试jekyll是否安装完毕：jekyll -v</p><p><a target="_blank" rel="noopener" href="https://i.loli.net/2019/02/23/5c7162bb03398.png"><img src="https://i.loli.net/2019/02/23/5c7162bb03398.png" alt="2019-02-23_230904.png"></a></p><p>   进入你的本地仓库 xxx.github.io这个文件夹中，打开命令行输入jekyll serve，一般会提示出现下面的Error，即是缺少jekyll-paginate</p><p>   直接在命令行里输入命令：gem install jekyll-paginate</p><p>   <a target="_blank" rel="noopener" href="https://i.loli.net/2019/02/23/5c7162edd73a1.png"><img src="https://i.loli.net/2019/02/23/5c7162edd73a1.png" alt="2019-02-23_231216.png"></a></p><p>   然后再进入你的本地仓库 xxx.github.io这个文件夹中，打开命令行里输入jekyll serve，你的博客就运行在本地4000端口上，复制这个网址在浏览器，你的每一次改动，博客都会动态变化，当所有改动完后，一次性性提交所有的changes即可</p><p>   <a target="_blank" rel="noopener" href="https://i.loli.net/2019/02/23/5c71632e4bb5d.png"><img src="https://i.loli.net/2019/02/23/5c71632e4bb5d.png" alt="2019-02-23_231337.png"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> jekyll </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
